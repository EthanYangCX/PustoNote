编译原理

程序设计语言编译原理

Principle of Compilation

编译器，Compiler，Compilateur，Compiler，Compilador，コンパイラ，컴파일러，Компиля́тор，Trình biên dịch

# 章一 引论

- 何为编译程序
    - `语言处理程序`か`翻译器`，将程序翻译成计算机能执行的形式
    - 语言处理程序常见的两类：
        - `解释程序`（Interpreter）：边解释边执行源语言程序，不产生目标语言程序な语言转换系统
            - onlineなの，程序と数据一起转为输出
            - 优势：运行发现错误不需查找整个程序，故易查错
        - `编译程序`（Compiler）：将源程序转成低级语言表示的目标程序
            - offlineなの，数据在运行时才参与
            - 优势：只需分析和翻译一次，故运行快
        - *（相同点は译成他）*
    - Java 语言处理器：编译と解释を结合。Java源程序首先编译为字节码という中间表示，然后虚拟机が字节码を解释执行。
        - 优势：一台机器上得到的字节码可在多平台机器执行
        - *（本来高级语言出现的一大好处就是不依赖特定机器、环境）*
- 编译过程概述：源程序👉五个阶段👉目标代码。五阶段如下
    - 词法分析（Lexical analysis）：源程序の字符流👉（を读し、`单词符号`（标识符、整数、界符等）を识别し、转换成）👉内部形式（二元组）
        - 依据：词法规则
        - 词法分析程序又叫`词法分析器`か`扫描器`
    - 语法分析（Syntax analysis）：词分丶器识别并转换的单词符号流👉（识别各个`语法单位`（短语、子句、语句、程序段、程序））👉另一种内部表示（如语法分析树）
        - 依据：语法规则
        - 语法分析程序又叫 `识别程序`
    - 另外：每阶段皆访问 `符号表`。
- 编译程序の结构
    - 总框
    - 符号表管理
    - 出错处理
    - 趟（遍）
    - 前端、后端
- 编译技术の发展と应用
    - 发展
    - 应用
    - 编译程序の分类
- 编译程序の生成
    - 手工编写
    - 自动构造工具
    - 技术

# 章二 高级语言及其语法描述

- 程序设计语言の定义
    - 定义
        - 语言定义的四个方面
            - 语法
            - 语义
            - 语用
            - 语境
    - 语法描述方式
        - 描述方式
            - 自然语言
            - 语法图
            - `巴斯克范式`か`BNF 范式`
            - 文法：见后
- 高级语言の一般特性
    - 高级语言的分类
    - 程序结构
    - 数据类型和操作
    - 语句与控制结构
    - 静态と动态
- 程序语言の语法描述
    - 引言——C 语言
    - 形式语言の基本概念
        - `字母表`
        - `符号`
        - `符号串`
        - `空符号串`
        - 符号串集合 U 和 V 的`（连接）积`
        - 符号串集合 V 的`闭包`
        - 符号串集合 V 的`正则闭包`
    - 上下文无关文法
        - 产生式（规则）
            - `→`（或 `::=`）读作「定义为」
            - 产生式`左部` `右部`
        - 文法：一组产生式（规则）の集合
        - 上下文无关文法：名之 G，是个四元组 $(V_T, V_N, S, P)$
            - 说明
    - 推导
        - `直接推出`
        - `推导`
        - `Ｏ可推导出Ｘ`，
            - `=>+`（$⟹^+$）：经1步或若干步
            - `=>*`（$⟹^*$）：经0步或若干步
        - `句型`
        - `句子`
        - `语言`
        - `最左（右）推导`。最右推导又称`规范推导`。
    - 分析树
    - 二义性：文法存在某句子对应两棵不同的语法树
    - 文法の分类：乔姆斯基が四类に分し，差别在对产生式的限制不同：
        - `0型文法`か`无限制文法`：动静符正包   定义为  动静符闭包。是以啥定以啥都行。
        - `1型文法`か`上下文有关文法`：动符左右可加物   定义为  动静符闭包（又有说右部叵S）。也就是只能把有动符的给定义为；而产生式左端可有静符，即可以已有之终结来化，故曰上下文有关
        - `2型文法`か`上下文无关文法`：单个动符 定义为  动静符闭包。
            - 以描述 **语法规则**
        - `3型文法`か`正规文法`：单个动符   定义为  静符闭包左右端之一可加单个动符。
            - 以描述 **词法规则**

# 章三 词法分析

- 对于词法分析器な要求
    - 任务
    - 单词符号の表示
    - 接口设计
- 词法分析器の设计
    - 词法分析器の结构
    - 状态转换图
    - 状态转换图の实现
- 正规表达式と有限自动机
    - 目的
    - 正规式と正规集
    - 确定有限自动机（DFA）
    - 非确定有限自动机（NFA）
    - 正规式与有限自动机の等价性
    - DFA の化简
- 词法分析器の自动生成
    - 用 lex 建立词法分析器の步骤
    - LEX 语言の一般描述
    - LEX の实现

# 章四 自上而下语法分析

- 语法分析器の功能
- 自上而下分析方法概述
- LL(1) 分析方法
- 递归下降分析程序
- 预测分析程序
- LL(1) 分析中的错误处理

# 章五 自下而上语法分析

- 自下而上分析方法概述
- 算符优先分析方法
- LR 分析方法
- 语法分析器の自动生成

# 章七 语义分析和中间代码生成（及 章六 属性文法和语法制导翻译）

- 任务：把语法单位翻译为中间代码
- 7.1 语法制导翻译概述
- 7.2 中间语言
- 7.3 说明语句の翻译
- 7.4 简单算术表达式と赋值语句の翻译
- 7.5 布尔表达式の翻译
- 7.6 控制语句の翻译
- 7.7 数组元素の引用
- 7.8 过程调用の翻译

# 章八 符号表

- 主为数构，不讲。

# 章九 运行时存储空间组织

- 任务：编译器须**实现**源程序之抽象概念，如名字、作用域、数据类型、过程、参数等；为此，编器**创建**并**管理**个**运行时刻环境**，处理许多事务，如为名字对象分配和安排存储位置、确定目标程序访问变量的机制、过程间连接、参数传递等。
- 9.1 目标程序运行时的活动
    - 过程嘅活动
        - `过程定义`：过程名+过程体
        - `过程调用`：过程名出现在可执行语句中
        - `过程的活动`：过程の一次执行
        - 活动的`生存期`：执行其各个操作序列的时间，包括调用其他过程の时
        - 注意：非递归な两过程の活动或不重叠或嵌套；过程递归则同时可有其数个活动活跃；组织存储空间，**要考虑**激活或返回自过程时，对局部名的处理，及是否允许静或动态存储分配等
    - 参数传递
        - 概念：调与被调过程间的信息传递以`参数`（谓`形式参数`과`实在参数`）或`全局量`
        - 의途径：**（作业点）**
            - `传地址`（call by reference）：把**实在参数的地址**传递给形式参数，被调段抄之入形式单元，过程体间接访问形式单元（个人理解，通过之而间接访问实参单元）
            - `得结果`（call by result）：形参有**两个**对应单元，分别存放实参的地址和值，返回前将单元二的内容放到单元一所指的实参单元
            - `传值`（call by value）：实参的值抄入形式单元，过程体直接访问形式单元，不改变实参的值
            - `传名`（call by name）：实际为替换方式，把被调过程体**抄写**到调用位置，形参替换成相应的实参（文字替换）
- 9.2 运行时存储器的划分
    - 存储器的划分：编器看来，目标程序运行在其**逻辑地址空间**，逻址空的运行时刻映像包含数据区和代码区
    - `活动记录`：连续的存储块，以存管理一个活动所需的信息
    - 存储分配策略
        - 考虑：程设语言本身的性质、支撑环境等
        - 常用的策略
            - 静态分配策略
            - 栈式动态分配策略
            - 堆式动态分配策略
- 9.3 静态存储管理—— FORTRAN 的存储分配（学了么？）
    - 概述
    - 存储器总体结构
    - COMMON 语句の处理
    - EQUIVALENCE 语句の处理
    - 地址分配算法
- 9.4 简单栈式动态存储分配的实现—— C 语言
    - 概述
    - C 的活动记录
      - 老 sp 即动态链
    - C 过程的处理
- 9.5 嵌套过程语言的栈式实现
    - 概述
        - 语言特点：过程嵌套定义、递归调用
        - 内层过程可引用任意外层的非局部数据，`最近嵌套原则`
        - 嵌套层次：假定主程序层数 0，内层依次++
        - P 内定义了 Q 且 P 是包围 Q 的最小过程则 P 是 Q 的`直接外层`
    - 存储组织：为访问非局部名字，需要跟踪每个外层过程最新活动记录的地址，方式有二
        - `静态链`：活动记录增加一个域谓静态链，指向直接外层的最新活动记录的地址
        - `嵌套层次显示表 DISPLAY`
            - 诞生背景：需跟踪所有外层过程的活动记录位置
            - 方法：进入过程时，建立活动记录时建立 DISPLAY 表。若过程层数 i，则 DISPLAY 有 i+1 项，记录 i,...,1,0 层的 sp
                - 非局部量地址 = Display[静态层数]+相对地址
            - 活动记录 **（作业点）** ：每个过程的活动记录，从低地址到高地址分别是：老 sp、返回地址、全局 DISPLAY、形参个数、形式单元（有几个形参就有几个它呗）、DISPLAY、简单变量と信息向量と临时单元（看过程里面定义啥变量之类的再加咯）
                - 主程序老 sp 写 0，无全局 DISPLAY，自己 DISPLAY 里就写自己的 0
                - DISPLAY 表的建立：当前层数是 i，则从调用者从底向上抄 i 项来，再添上自己的当前 sp
                    - 也就是，抄了所有外层程序，如果调用者跟自己并列就不抄调用者自己的，否则（调用者是直接外层）那自然也抄调者添的那个元素
                - 由是可写「整个运行栈」
            - 设 display  相对地址为 d，则引用外层 k 的变量 X 使用的变址指令可以是：
                - `LD R1, (d+k)[sp]`
                - `LD R2, X[R1]`
    - 过程의处理

# 章十 优化

- 任务：程序を等价变换，使可生更有效な目标代码
- 10.1 优化概述
    - 问题提出
    - 解决之道
    - 优化方法，按优化所涉及的程序范围分：
        - 局部优化
        - 循环优化
        - 全局优化
- 10.2 `局部优化`：程序を化为若干基本块，各基本块中分别进行的优化谓
    - 10.2.1 基本块和流图 **（作业点）**
        - `基本块`：程序にの顺序执行な语句（四元式）序列，仅一个入口（第一个语句），一个出口（最后个语句），执行仅能自入入自出出
        - 划分基本块算法
            - 步一：求入口语句，即（析取）：*（盖天启或ifelse启）*
                - 程序首语句
                - 转移语句所转到
                - 紧跟在条件转移句后
            - 步二：构每一入口嘅基本块，从入句直到（析取）：*（盖启后或绝后）*
                - 下一入句（不含）
                - 一转移句（含）
                - 一停句（含）
            - 步三：非任块者为叵达，悉删
        - 程序流图（程序控制流程图）：基本块集合上加控制流信息来表示程序
            - `流图`か`控制流程图`：具有唯一首结点的有向图 $G=(N, E, n_0)$
                - `首结点`：即到图中任一结点均有通路
            - 程序流图
                - 结点集$N$为基本块集，首结点$n_0$为含有第一个语句な基本块，有向边集$E$（的元素$(i,j)$）构成规则（析取）：*（盖直达转达皆是达）*
                    - i 之出口非转句或停句，且 j 紧跟其后
                    - i 之出句是转句，且转到 j 之入口
        - 基本块内的优化
    - 10.2.2 基本块的 DAG 表示及其应用 **（作业点）**
        - DAG
            - 基本块的DAG（以描述计算过程）为结点附加了信息
                - 叶结点：下标记は常数或标识符，右标记は标识符
                - 内节点：下标记は运算符，右标记は标识符
            - *（注意：箭头方向竟然是往下指）*
        - 构造基本块 DAG 优化四元式
            - 构造算法
                - 大意（对每个四元式 A:=B 或 A:=op B 或 A:=B op C）：
                    - 构造 B、C 的叶节点
                    - 检查合并已知量：运算对象皆常数则生成运算结果的节点，标记为A
                    - 检查公共子表达式：若为公子（DAG有B op C之节点）则为加右标记
                    - 检查无用赋值：若NODE[A]已是某节点右标记，从该右标记集合删之再建新
        - DAG 的其他优化信息
            - 优化信息
            - 进一步优化——删除其他形式的无用赋值
                - 赋值永不引用：不出现在任何基本块叶节点下标记，且无前驱
                - 被定值但仅在递归赋值中引用
                - 仅作为中间变量
            - *（主には说不再引用的节点就甭管了）*
        - DAG 构造算法的进一步讨论
- 10.3 循环优化 **（作业点）**
    - 循环的定义
        - 定义，流图中满足以下性质的节点序列（合取）：
            - 强连通，即任二间有通路，通路上节点均属该序列；单节点有自回路
            - 有且仅一个入口
    - 循环优化方法（不要求算法，三种观察下）
        - 代码外提
            - 循环不变运算
            - 循环不变运算外提的条件
            - 代码外提算法
        - 强度削弱
        - 删除归纳变量（变换循环控制条件）
        - 算法步骤 von der 强度削弱과删除归纳变量

# 章十一 目标代码生成

- 任务：优化后的中间代码を语义等价的目标代码に变换。要求正确、易于实现、高效运行
- 11.1 代码生成器设计中的问题
- 11.2 一个计算机模型
- 11.3 简单代码生成器
- 11.4 寄存器分配（不讲）
- 11.5 DAG 的目标代码（不讲）

# 些问题

- 章二，一开始说语言定义有四个方面，后来讲到文法又说语言是文法产生句子的全体，这两处应该是用「语言」这个词表达了不同的概念。常说的「程序设计语言」之「语言」当指前者，而且自然语言也和前者更接近（吧）。但这门课出的题目里，一般指后者。又或者，这两者就是同一个概念，只是我领悟不到家。
