编译原理

程序设计语言编译原理

Principle of Compilation

编译器，Compiler，Compilateur，Compiler，Compilador，コンパイラ，컴파일러，Компиля́тор，Trình biên dịch

# 章一 引论

- 何为编译程序
    - `语言处理程序`か`翻译器`，将程序翻译成计算机能执行的形式
    - 语言处理程序常见的两类：
        - `解释程序`（Interpreter）：边解释边执行源语言程序，不产生目标语言程序な语言转换系统
            - onlineなの，程序と数据一起转为输出
            - 优势：运行发现错误不需查找整个程序，故易查错
        - `编译程序`（Compiler）：将源程序转成低级语言表示的目标程序
            - offlineなの，数据在运行时才参与
            - 优势：只需分析和翻译一次，故运行快
        - *（相同点は译成他）*
    - Java 语言处理器：编译と解释を结合。Java源程序首先编译为字节码という中间表示，然后虚拟机が字节码を解释执行。
        - 优势：一台机器上得到的字节码可在多平台机器执行
        - *（本来高级语言出现的一大好处就是不依赖特定机器、环境）*
- 编译过程概述：源程序👉五个阶段👉目标代码。五阶段如下
    - 词法分析（Lexical analysis）：源程序の字符流👉（を读し、`单词符号`（标识符、整数、界符等）を识别し、转换成）👉内部形式（二元组）
        - 依据：词法规则
        - 词法分析程序又叫`词法分析器`か`扫描器`
    - 语法分析（Syntax analysis）：词分丶器识别并转换的单词符号流👉（识别各个`语法单位`（短语、子句、语句、程序段、程序））👉另一种内部表示（如语法分析树）
        - 依据：语法规则
        - 语法分析程序又叫 `识别程序`
    - 语义分析（Semantic analysis）和中间代码生成：语法分析树或其他内部中间表示👉静态语义检查👉生成目标代码或中间代码
        - 语义分析は审查源程序的语义
            - 为代码生成阶段收集类型信息，如类型检查
            - 识别含义与相应的语义处理
            - 其他静态语义检查
        - 中间代码：为了便于优化
    - 中间代码优化
    - 目标代码生成
    - 另外：每阶段皆访问 `符号表`。
- 编译程序の结构
    - 总框
    - 符号表管理
    - 出错处理
    - 趟（遍）
    - 前端、后端
- 编译技术の发展と应用
    - 发展
    - 应用
    - 编译程序の分类
- 编译程序の生成
    - 手工编写
    - 自动构造工具
    - 技术

# 章二 高级语言及其语法描述

- 程序设计语言の定义
    - 定义
        - 语言定义的四个方面
            - 语法
            - 语义
            - 语用
            - 语境
    - 语法描述方式
        - 描述方式
            - 自然语言
            - 语法图
            - `巴科斯范式`か`BNF 范式`
            - 文法：见后
- 高级语言の一般特性
    - 高级语言的分类
    - 程序结构
    - 数据类型和操作
    - 语句与控制结构
    - 静态と动态
- 程序语言の语法描述
    - 引言——C 语言
    - 形式语言の基本概念
        - `字母表`
        - `符号`
        - `符号串`
        - `空符号串`
        - 符号串集合 U 和 V 的`（连接）积`
        - 符号串集合 V 的`闭包`
        - 符号串集合 V 的`正则闭包`
    - 上下文无关文法
        - 产生式（规则）
            - `→`（或 `::=`）读作「定义为」
            - 产生式`左部` `右部`
        - 文法：一组产生式（规则）の集合
        - 上下文无关文法：名之 G，是个四元组 $(V_T, V_N, S, P)$
            - 说明
    - 推导
        - `直接推出`
        - `推导`
        - `Ｏ可推导出Ｘ`，
            - `=>+`（$⟹^+$）：经1步或若干步
            - `=>*`（$⟹^*$）：经0步或若干步
        - `句型`
        - `句子`
        - `语言`
        - `最左（右）推导`。最右推导又称`规范推导`。
    - 分析树
    - 二义性：文法存在某句子对应两棵不同的语法树
    - 文法の分类：乔姆斯基が四类に分し，差别在对产生式的限制不同：
        - `0型文法`か`无限制文法`：动静符正包   定义为  动静符闭包。是以啥定以啥都行。
        - `1型文法`か`上下文有关文法`：动符左右可加物   定义为  动静符闭包（又有说右部叵S）。也就是只能把有动符的给定义为；而产生式左端可有静符，即可以已有之终结来化，故曰上下文有关
        - `2型文法`か`上下文无关文法`：单个动符 定义为  动静符闭包。
            - 以描述 **语法规则**
        - `3型文法`か`正规文法`：单个动符   定义为  静符闭包左右端之一可加单个动符。
            - 以描述 **词法规则**

# 章三 词法分析

- 对于词法分析器な要求
    - 任务：左到右，逐字符扫描，产单词符号
    - 单词符号の表示：一般为二元式 <单词种别，属性值>
        - `单词种别`：由语法分析阶段使用的抽象符号，影响语分决策
            - 分类
            - 种别编码方案：关键字、运算符、界符一字一码，标识符一种，常数按类型分种
        - `属性值`：翻译成目标代码时，相同种别不同单词符号翻译结果不同也
            - 编码：键、算、界不需，识、常は指针
    - 接口设计
        - 作为独立一遍：文件中保存整个程序の内码形式，语法分析进入工作时从文件输进
        - 作为子程序：调用一次识别并输出一个单词给语法分析器
- 词法分析器の设计
    - 词法分析器の结构
        - 整体：![词法分析器结构](./pic/StructDLexAnly.png)
        - `预处理子程序`：合空，去注，聚模块，换宏
        - `扫描缓冲区`の设计
            - 双指示器：（单词）起点指示器、搜索（词尾）指示器
            - 双区缓冲：分为等长两半区。半区长度≥标识符允许长度-1（即保证第一个半区末字个单词的话，仍能读完此词）
        - 历史上词法定义中的一些问题：忽略空格（解以向前搜索）、关键字不保留、关键字と保留字と标准标识符の区别
    - `状态转换图`
        - 用正规文法描述的词法规则，其识别单词符号的过程可用`状态转换图`という有限方向图表示。状换图识别词符过程易于程序实现。
        - 定义：有限方向图，节点は状态，箭弧の标记は字符は射出节点状态下的输入字符，只有一个初态，至少一个终态（双圈表示）（终态加星号表示吐回一个来）
        - で识别单词符号な过程
        - （某例题の约定：关键字为保留字；保留字作标识符处理并用保留字表识别；关键字、标识符、常数间若无算符或界符则加一空格）
    - 状态转换图の实现
        - 变量和过程
        - 程序段
        - 扫描器总控程序
- 正规表达式と有限自动机
    - 目的：形式化描述词法规则と词法分析程序
    - 1 正规式と正规集
        - 定义：空串、空集、字母表的元素都是`正规式`，正规式的或（`|`）、连接（`·`）、闭包（`*`）有限次使用得到的表达式亦是，正规式表示的字集谓`正规集`（对应于正规集做并、交、闭）
        - 两个正规式，表示的正规集相同，视作`等价`（`=`）
        - 正规式运算规律：交换律、结合律、分配律（把或当加，积当乘）、闭は幂等
    - 2 确定有限自动机（DFA）
        - 定义：一个五元式 $M=(S,Σ,δ,S_0,F)$
            - 其中（组元と关系と特元だ）：Sは状态の有限集，Σは有穷字母表，δは状态と输入字符を下状态（谓后继状态）に映射，S0は唯一初态，Fは终态集はS的子集
        - DFA 与状态转换矩阵：行表示状态，列表示输入字符，元素表示δ值
        - DFA 与状态转换图：假定m态n符，必有m结点，每点最多n弧，每弧不同输入字符で标记，唯一初，若干（或0）终
        - DFA M所识别的字(工作过程)
            - 若有通路，弧连而为α，αは`可被接受/识别/读出`。识别全体 `L(M)`
            - 若S0∈F，ε可接受。
    - 3 非确定有限自动机（NFA）
        - 定义（、状态转换图）：其中，输入的可以是**好几个字**（$∈Σ^*$），δ映之到**状态子集**，射出弧数目可以＞n，且可相同或为ε；且初态可不止一个
        - NFA 的工作过程
        - 结论：DFA是NFAの特例，每个NFA M有一个等价的DFA M'
        - 有限自动机`等价`：即L(M1)=L(M2)
    - 4 正规式与有限自动机の等价性
        - 定理：正规式と有限自动机が等价；即，任NFA M存正规式V，任V存DFA M，使L()=L()
        - 证明 NFA->V （构造法）
            - 拓广状态转换图：有向边可用正规式标记
            - 步骤：增加初终态结点X、Y，反复把各种组合换成一条正规式的边
        - 证明 V->DFA
            - 第一步：构 NFA。NFA->V的构造法を念来过倒
            - 第二步：确定化
                - 对状态子集I，定义`ε-闭包` `ε-CLOSURE(I)`：I中状态∈之，自I中状态经任意条ε弧可达者∈之。*（即各走空串的、不走的都进。实际就是无空化的你。串は等价嘛。）*
                - 对状态子集I、符号a，定义 `Ia`：从I中状态经一条a弧到达的状态节点全体为J，Ia=ε-CLOSURE(J) *（即一步a再求空闭）*
                - `确定化`（子集法）
                    - 构造状态转换矩阵。每一列是求各种一步空闭，有元素a,b就写Ia,Ib。先第一行，始点の空闭
                    - 矩阵出现新元素都用它写新行。直到无新
            - 第三步：对状态子集（矩阵元素）中心命名，得新状转矩
            - 第四步：画出状转图
    - 5 DFA の`化简`（`最小化`）：找个状态数更少的，最少的
        - 术语
            - 状态sとt`等价`：从你出发你能读出那我也能
            - 状态sとt`可区分`：不等价。例如终态と非终态可区分。
        - 思路：（关系论の）划分，异子集状态可区分，同子集状态等价
        - 步骤
            - 初始划分：终态集，非终态集
            - 检查划分的每个子集Ik可否再分，依据：若存在符a使Ika不全包含在现行划分πの成员中，Ik再划（划为使落入同集）
            - 直到π的成员不再增
- 词法分析器の自动生成
    - 用 lex 建立词法分析器の步骤
    - LEX 语言の一般描述
    - LEX の实现

# 章四 自上而下语法分析

- 语法分析器の功能：判单词序列合法否，即按文法产生式判符号串是句子
- 自上而下分析方法概述
    - 基本思想：自上而下建树也，即从始符找最左推导。带回溯的试探过程。
    - 面临的问题：若有左递归，使无限循环。回溯使大段错路。存在虚假匹配。
- LL(1) 分析方法
    - 定义：L（左）からL（左推）を构，每步向前看一个字符。
    - 目的：构不带回溯的上而下
    - 消除左递归
        - 消除直接左递归：加个辅助符号改右递也。辅助符号那里把该递的α右递了，再接β右边
            - P→P α1│Pα2 │… │Pαm │β1 │β2 │… │βn 改为 P→ β1 P'│β2 P'│...│βn P' ；P'→ α1 P'│ α2 P'│… │αm P'│ε
            - **记得批撇定以空串。也别忘写撇号。**
        - 消除间接左递归：
            - 化直：就是先给各动符排序，每个动符（i=1:n）据它前面的动符（j=1:i-1）更拆（把Pj的Pi换掉），每步i消直，最后删不使用的式
    - 消除回溯、提左因子
        - 消除回溯：保证任动符，匹配入串可据输入准确指派候式，成则不虚假，败则他亦败
            - 即任动符A面对输入，准确指派一右部，其成败即A之成败，无需试探、回溯
        - 定义 —— 符号串α的`终结首符集`（首符集） `FIRST(α)`
            - 即符串が推至最后的静符串可用何符始。特别地，可推ε则ε∈FIRST
            - ∀动符，欲准确指派，应满足候选式FIRST互交皆空
        - 提取左因子：左边有相同成分固然同FIRST，故把同左因子之式，左因子提出来，右因子打包给新符。
            - 一般反复提左（包括先换掉最左な动符）可使每个动符所有候选首符集两两不交
        - 结论
            - 若无左归、候交空，则对入符a及待匹配な动符，a属于哪个候选式的首符集就用哪个候选式工作。这种选择唯一、确定、无虚假。
    - LL(1) 分析条件
        - 问题：即便有无左、FIRST两条件，仍有漏掉的情况，因空串候选式
        - 定义 —— A的`后继终结符号集` `FOLLOW(A)`
            - 始符が推し，可挨在A之后者。
                - 若始符推A可在末尾，则`#`属于其FOLLOW。
            - 动符面临入符a，若a不属于任何候选式のFIRST，于ε∈FIRST(A)，且a∈FOLLOW(A)，就采纳空串。
            - 此时有A之FIRST与FOLLOW不交
        - LL(1) 分析条件：无左归，每动符候式首符集不交，若首符可空则其首符后符集不交
            - 满足则称 LL(1) 文法
        - LL(1) 分析方法：入a，匹以A，A各候式α，若a∈FIRST(αi)，则指派αi，否则若ε∈FIRST(A)且a∈FOLLOW(A)，指派ε，否则语法错
    - FIRST 集合和 FOLLOW 集合の构造
        - 对每个静符，FIRST(X)：等于自个集合
        - 对每个动符，FIRST(X)
            - 有候式首a则a进，候式ε则ε进
            - 凡候式首个动符的FIRST去掉ε加入。忽略掉最前面几个可定以ε者后的首个动静符的FIRST亦去ε加入，
                - 去ε是因为FIRST里ε含义特殊，指整个A都用ε，故需要整个可ε才能
            - 特别地，如果某候式所有动符，ε∈FIRST，则ε可加入。
        - 对每个候选式，FIRST(α)
            - 与动符同。首动静符的FIRST去ε加入，忽略前面的FIRST可ε者的首动静符去ε加入，整体全可ε则ε加入
        - 对每个动符，FOLLOW(A)
            - 若为始符，置个`#`
            - 若有候式，A后面β，FISRT(β)-ε入
            - 若有产式B→αA，或A后跟可推ε者，FOLLOW(B)入
            - 反复直到不增
        - **【浦：凡FIRST，首，忽，全空】**
        - **【浦：凡FOLLOW，始，后，母尾】**
- 递归下降分析程序（不考程序，故这里没有好考的）
    - 定义
    - 程序构造
    - 扩展的巴科斯范式 EBNF、语法图及分析程序构造
        - EBNF：元符号除了`→` `|` 还有 `{}`（闭包或指定出现次数）、`[]`（出现0或1次）
- 预测分析程序
    - 概念：递丶降需递归，显式维个**栈**可构非递
    - 关键：如何选候选式
    - 组成：预测分析表（LL(1) 分析表）、符号栈、总控程序
        - 预测分析表M：行は动符，列は静符加`#`，元素は产生式はA面临a当用此（或空白，表出错）
        - 符号栈：放文法符号，初始放`#`，再放始符
        - 总控程序：任何栈顶X入符a执行三种动作之一
            - X=a=`#`は成功
            - X=a≠`#`はX弹出，a指下一个入符
            - X动符，按M(X,a)推导（弹出X，右部符号串反序入栈（即栈顶是首符，其他在栈内））或出错处理
    - 预丶表を构：
        - 对每个产生式A→α
            - FIRST(α)每个终符，A→α加入M(M,a)
            - ε在FIRST(α)则FOLLOW(A)的每个终符b包括\#，A→α加入M(A,b)
        - **【浦：凡产式，于锕首，锕空于誒后】**
    - 分析表每一项不含多重定义入口 iff LL(1)文法
    - 总控程序の形式化描述 **【浦：顶入同井成，同静消，否换顶】**
- LL(1) 分析中的错误处理
    - 出错场合
    - 错误恢复の思路
    - 处理方法

# 章五 自下而上语法分析

- 5.1 自下而上分析方法概述
    - 语法分析の任务：按文法产生式分析输入串为句否
    - 语法分析の方法：上而下は推导，下而上は归约
    - 归约と分析树
        - 移进-归约法：使用符号栈，符号逐一移进，栈顶出现某产生式右部辄归约为左部
        - 分析树：用树表示移归过程
        - 关键：何时归约、找可归约串（产式右部符串）
    - 规范规约简述
        - 定义
            - 短语：句型其一部分可由个动符导，称为迊句型关于迊动符的短
            - 直接短语：导仅一步，称句型关于产生式的直短
            - 句柄：句型の最左直短
            - 句型语法树で：子树の叶は字数根にの短，两层子树は直短，最左的两层树は句柄
        - 规范规约：序列，从句子到始符每步是将句柄替换成相应产式左部
            - 最右推导（又称规范推导）の逆过程
    - 符号栈の使用：符号栈、输入串、动作
- 5.2 算符优先分析方法
    - 5.2.1 基本思想：`简单优先分析法` 找所有符号优先关系，规范但低效。算丶优は终符（算符）の优先关系，非规范归约但快，适用于表达式
    - 5.2.2 优先关系：任何两个可能（或隔动符）相继的终符，优先关系三种，高等低
    - 5.2.3 算符优先文法和优先关系表的构造
        - 算优只适用于算符优先文法
        - 1 算符文法：任意产式右不含相继的非终
        - 2 算符优先关系：后生的高
        - 3 算符优先文法：算符文法中任何终符对最多满足三关系之一
        - 4 优先表の构造
            - （动符Pの）FIRSTVTとLASTVT
                - 定义：可以在P推导的符号串里做首/末个终符（无论前后是否有非终）
                - 使用：候选式有aPb则a < 任在 FirstVt(P)，任在 LastVt(P) > b
                - 构造：直合（有候选式首个终符是a则a进），或有产首符为非终Q则吸Q之FV入FV，同理LV
                - 构造算法：个布尔矩阵表列是否行的FV，个栈用来存放第一次判FV真的偶对（P,a）。初始皆非，直合的判真压栈，栈每元(Q,a)找候式首符Q者P->Q...，把(P,a)（若首次）判真压栈
            - 优先关系表
                - 行元何于列元
                - 构造算法：每条产式，每个元i看下个或下下，i&i+1是终符则置等于，i终i+1动i+2终等于，i终i+1动则i小于FiVt(i+1)，i动i+1终大于
    - 5.2.4 算符优先分析算法の设计
        - 1 最左素短语：算优析にの可归约串
            - `素短语`：至少一个终符，且无更小素短语
            - `最左素短语`
        - 2 定理：算优文任何句型最左素短语是满足以下条件な最左子串：左邻静符小于之，之内静符相等，之大于右邻静符
        - 3 算符优先分析算法：逐个入栈，直到栈顶大于待入，再往前找外符小于左素首，左素归约为非终N（及相应语义处理）
    - 5.2.5 优先函数
        - 优点：节省空间，易比优
        - 定义
        - 构造方法一（偶图）
        - 构造方法二（Floyd 迭代法）
    - 文法在内存中な表示
- 5.3 LR 分析方法
    - 概念
        - L（左）から（从左向右）R（最右推导）の逆を构造。
            - LR(k)每步至多向前检查k个输入符号，0只根据当前符号と历史信息而不展望
        - 严格的规范规约
    - 基本思想：用历史（已移进和规约的串）、现实（输入符号）、展望（根据所用产式推测未来可遇的入符），来确定栈顶符号串为否某产生式の句柄
    - 5.3.1 LR 分析器
        - 总控程序：所有LR分析器同
        - 分析表，四种，LR(0)，SLR，规范LR，LALR
        - 分析栈：栈每项两个内容，状态、符号。状态概括了历史、展望资料
        - 分析表：两部分
            - 动作（ACTION）表：状态S面临入符a采取的动作
                - 移进Sj：当前a和状态j移进栈
                - 归约rj：按第j个产生式归约
                - 接受acc：成功
                - 出错（空白或出错处理）
            - 状态转换（GOTO）表：状态S面对文法符号X下一状态是何。对终符，GOTO和ACTION写在一起。
        - `LR文法`：能构造LR分析表，每个入口唯一确定则谓。分析时一旦栈顶形成句柄即可归约。
    - 5.3.2 LR(0) 分析表的构造
        - 1 概念
            - `前缀`：符号串の任意首部
            - `活前缀`：最右推导句型（规范句型）の前缀，且不超句柄右端。
            - LR 分析器工作过程即逐步产生文法の规范句型活前缀，栈顶形成句柄辄归约，LR分析表转移函数本质为识别活前缀的DFA
        - 2 构造 LR(0) 分析表
            - 术语 —— `LR(0) 项目`か`项目`：右部某处加点な产生式，加点是用来表示分析过程中的状态。空串只有一个状态，一个点也
            - 构造 LR(0) 分析表の两大步骤
                - 第一步：从文法构造识别活前缀的 DFA
                    - 方法一：求出文法的所有项目，按一定规则构造 NFA 再确定化为 DFA
                        - 拓广文法：引入新的始符S'使仅在第一个产生式左部
                        - 构造 NFA：状态节点は项目；有向边は，同一个产生式跳过一个a写a，从X→·A到A→·γ写ε，确定化出`项目集`，项目集的集合`项目集规范族`
                    - 方法二：直接构造 DFA
                        - 定义一：项目集闭包函数 closure(I)：项目I本身，以及I的点后元素为左部、右部首为点的项目，重复直到不扩大
                        - 定义二：状态转移函数 GO：GO(I,X)即I右部跳过X的全体J的闭包clo(J)
                        - 思想：从S'→·S开始得DFAの初态项目集I0，不断求GO若GO(I,X)非空且不在结果C中则加入，直到不再增大
                        - 若文法G识别活前缀的DFA每个状态不存在任何冲突项目（移进和规约并存、多个规约并存），谓`LR(0)文法`
                - 第二步：从上述 DFA 构造分析表
                    - 概念
                        - 定义 —— 项目对或前缀`有效`。规约项目点在尾，移进项目点在中。
                        - 符号栈活前缀的有效项目集即栈顶状态表示的集合，集合中不同项目表明不同动作，以此填表
                    - 分析表的构造：
                        - 若移进a的项目属于Ik，GO(Ik,a)=Ij，则ACTION[ k,a ]=sj
                        - 若归约（末点）项目属于Ik，任意终符（包括井）置 ACTION[ k,a ]=rj（j为此产生式编号）
                        - 若S'→S·∈Ik，ACTION[ k,井]=acc
                        - 若GO(Ik,A)=Ij，置GOTO[ k,A ]=j
                        - 其余空白
    - 分析表构造步骤：拓广文法；写项目；用clo和GO求项目集规范族C；构造识别文法G'所有活前缀的DFA；根据DFA构造LR(0)表
    - 分析过程：三元式即状态、符号、输入串。看ACTION[ 状态顶、入符 ]
        - ACT为移进且GOTO为j则j压到状态，入符压到符号
        - ACT为归约A→β，β长r，则前r状态、符号消失，A入符号栈，GOTO[ Sm-r，A ] 入状态栈
    - LR(0) 分析法存在的问题：存在移进归约或归约归约冲突，则有多重定义入口，动作不唯一
- 5.4 语法分析器の自动生成：YACC
- LR 分析方法和 LL 分析方法的比较

# 章七 语义分析和中间代码生成（及 章六 属性文法和语法制导翻译）

- 任务：把语法单位翻译为中间代码
- 7.1 语法制导翻译概述
    - 1 属性文法
        - `属性`：上下无关文の基础上，描述语义动作时，每文法符号配备若干相关的「值」，如类型、地址，谓属性
        - `语义规则`：与文法产生式关联な一组属性计算规则
        - `属性文法`：对文法每个产生式给出语义规则な文法
        - `翻译模式`：属性文法是高级规范说明，隐去细节，翻译模式是语言翻译的另一种描述，给出使用语义规则计算的次序，即表示实现细节
            - 其中和文法符号相关的属性和语义规则用花括号括，谓 `语义动作`か`语义子程序`
    - 2 语法制导翻译方法
        - 基本思想：语法分析时执行语义子程序
        - 实现途径：（1）扩大语法分析器功能，归约/推导时调用子程序（2）分析栈改为语义栈（状态、值、符号）
- 7.2 中间语言
    - `后缀式表示法`か`逆波兰表示法`
        - 条件算术の
    - `树`：后缀式は树の后序遍历
    - `三地址代码`：一般形式为……，具体实现时表示为记录结构：
        - `四元式`：联系は临时变量
        - `三元式`：通过语句位置引用临时变量
        - `间接三元式`：不直接使用三元式表，而另设间接码表，
- 7.3 说明语句の翻译
    - 说明语句の作用：用关键字定义名字的性质
    - 语义动作
    - 1 简单类型说明
        - 文法
        - 改写文法
        - 语义变量与语义过程
        - 翻译模式
    - 2 数组说明
        - 文法
        - 信息向量表
        - 可变数组の处理
- 7.4 简单算术表达式と赋值语句の翻译
    - 概念
    - 1 文法描述
    - 2 语义变量と语义过程
    - 3 语义子程序
    - 语法制导翻译过程：栈、输入串、i.place、四元式
    - 4 类型转换
- 7.5 布尔表达式の翻译
    - 1 布尔表达式の定义
    - 2 数值表示法的布尔式翻译
    - 3 作为条件控制的布尔表达式的翻译
- 7.6 控制语句の翻译
    - 1 控制流语句
    - 2 标号语句と goto 语句
    - 3 case 语句
    - 4 for 语句
- 7.7 数组元素の引用
    - 问题
    - 1 数组说明
    - 2 地址计算
    - 3 中间代码形式
    - 4 翻译方法
- 7.8 过程调用の翻译
    - 过程调用の实质
    - 1 基本思想
    - 2 翻译方法
    - 3 过程调用与数组元素相混淆的处理

# 章八 符号表

- 主为数构，不讲。

# 章九 运行时存储空间组织

- 任务：编译器须**实现**源程序之抽象概念，如名字、作用域、数据类型、过程、参数等；为此，编器**创建**并**管理**个**运行时刻环境**，处理许多事务，如为名字对象分配和安排存储位置、确定目标程序访问变量的机制、过程间连接、参数传递等。
- 9.1 目标程序运行时的活动
    - 过程嘅活动
        - `过程定义`：过程名+过程体
        - `过程调用`：过程名出现在可执行语句中
        - `过程的活动`：过程の一次执行
        - 活动的`生存期`：执行其各个操作序列的时间，包括调用其他过程の时
        - 注意：非递归な两过程の活动或不重叠或嵌套；过程递归则同时可有其数个活动活跃；组织存储空间，**要考虑**激活或返回自过程时，对局部名的处理，及是否允许静或动态存储分配等
    - 参数传递
        - 概念：调与被调过程间的信息传递以`参数`（谓`形式参数`과`实在参数`）或`全局量`
        - 의途径：**（作业点）**
            - `传地址`（call by reference）：把**实在参数的地址**传递给形式参数，被调段抄之入形式单元，过程体间接访问形式单元（个人理解，通过之而间接访问实参单元）
            - `得结果`（call by result）：形参有**两个**对应单元，分别存放实参的地址和值，返回前将单元二的内容放到单元一所指的实参单元
            - `传值`（call by value）：实参的值抄入形式单元，过程体直接访问形式单元，不改变实参的值
            - `传名`（call by name）：实际为替换方式，把被调过程体**抄写**到调用位置，形参替换成相应的实参（文字替换）
- 9.2 运行时存储器的划分
    - 存储器的划分：编器看来，目标程序运行在其**逻辑地址空间**，逻址空的运行时刻映像包含数据区和代码区
    - `活动记录`：连续的存储块，以存管理一个活动所需的信息
    - 存储分配策略
        - 考虑：程设语言本身的性质、支撑环境等
        - 常用的策略
            - 静态分配策略
            - 栈式动态分配策略
            - 堆式动态分配策略
- 9.3 静态存储管理—— FORTRAN 的存储分配（学了么？）
    - 概述
    - 存储器总体结构
    - COMMON 语句の处理
    - EQUIVALENCE 语句の处理
    - 地址分配算法
- 9.4 简单栈式动态存储分配的实现—— C 语言
    - 概述
    - C 的活动记录
      - 老 sp 即动态链
    - C 过程的处理
- 9.5 嵌套过程语言的栈式实现
    - 概述
        - 语言特点：过程嵌套定义、递归调用
        - 内层过程可引用任意外层的非局部数据，`最近嵌套原则`
        - 嵌套层次：假定主程序层数 0，内层依次++
        - P 内定义了 Q 且 P 是包围 Q 的最小过程则 P 是 Q 的`直接外层`
    - 存储组织：为访问非局部名字，需要跟踪每个外层过程最新活动记录的地址，方式有二
        - `静态链`：活动记录增加一个域谓静态链，指向直接外层的最新活动记录的地址
        - `嵌套层次显示表 DISPLAY`
            - 诞生背景：需跟踪所有外层过程的活动记录位置
            - 方法：进入过程时，建立活动记录时建立 DISPLAY 表。若过程层数 i，则 DISPLAY 有 i+1 项，记录 i,...,1,0 层的 sp
                - 非局部量地址 = Display[静态层数]+相对地址
            - 活动记录 **（作业点）** ：每个过程的活动记录，从低地址到高地址分别是：老 sp、返回地址、全局 DISPLAY、形参个数、形式单元（有几个形参就有几个它呗）、DISPLAY、简单变量と信息向量と临时单元（看过程里面定义啥变量之类的再加咯）
                - 主程序老 sp 写 0，无全局 DISPLAY，自己 DISPLAY 里就写自己的 0
                - DISPLAY 表的建立：当前层数是 i，则从调用者从底向上抄 i 项来，再添上自己的当前 sp
                    - 也就是，抄了所有外层程序，如果调用者跟自己并列就不抄调用者自己的，否则（调用者是直接外层）那自然也抄调者添的那个元素
                - 由是可写「整个运行栈」
            - 设 display  相对地址为 d，则引用外层 k 的变量 X 使用的变址指令可以是：
                - `LD R1, (d+k)[sp]`
                - `LD R2, X[R1]`
    - 过程의处理

# 章十 优化

- 任务：程序を等价变换，使可生更有效な目标代码
- 10.1 优化概述
    - 问题提出
    - 解决之道
    - 优化方法，按优化所涉及的程序范围分：
        - 局部优化
        - 循环优化
        - 全局优化
- 10.2 `局部优化`：程序を化为若干基本块，各基本块中分别进行的优化谓
    - 10.2.1 基本块和流图 **（作业点）**
        - `基本块`：程序にの顺序执行な语句（四元式）序列，仅一个入口（第一个语句），一个出口（最后个语句），执行仅能自入入自出出
        - 划分基本块算法
            - 步一：求入口语句，即（析取）：*（盖天启或ifelse启）*
                - 程序首语句
                - 转移语句所转到
                - 紧跟在条件转移句后
            - 步二：构每一入口嘅基本块，从入句直到（析取）：*（盖启后或绝后）*
                - 下一入句（不含）
                - 一转移句（含）
                - 一停句（含）
            - 步三：非任块者为叵达，悉删
        - 程序流图（程序控制流程图）：基本块集合上加控制流信息来表示程序
            - `流图`か`控制流程图`：具有唯一首结点的有向图 $G=(N, E, n_0)$
                - `首结点`：即到图中任一结点均有通路
            - 程序流图
                - 结点集$N$为基本块集，首结点$n_0$为含有第一个语句な基本块，有向边集$E$（的元素$(i,j)$）构成规则（析取）：*（盖直达转达皆是达）*
                    - i 之出口非转句或停句，且 j 紧跟其后
                    - i 之出句是转句，且转到 j 之入口
        - 基本块内的优化
    - 10.2.2 基本块的 DAG 表示及其应用 **（作业点）**
        - DAG
            - 基本块的DAG（以描述计算过程）为结点附加了信息
                - 叶结点：下标记は常数或标识符，右标记は标识符
                - 内节点：下标记は运算符，右标记は标识符
            - *（注意：箭头方向竟然是往下指）*
        - 构造基本块 DAG 优化四元式
            - 构造算法
                - 大意（对每个四元式 A:=B 或 A:=op B 或 A:=B op C）：
                    - 构造 B、C 的叶节点
                    - 检查合并已知量：运算对象皆常数则生成运算结果的节点，标记为A
                    - 检查公共子表达式：若为公子（DAG有B op C之节点）则为加右标记
                    - 检查无用赋值：若NODE[A]已是某节点右标记，从该右标记集合删之再建新
        - DAG 的其他优化信息
            - 优化信息
            - 进一步优化——删除其他形式的无用赋值
                - 赋值永不引用：不出现在任何基本块叶节点下标记，且无前驱
                - 被定值但仅在递归赋值中引用
                - 仅作为中间变量
            - *（主には说不再引用的节点就甭管了）*
        - DAG 构造算法的进一步讨论
- 10.3 循环优化 **（作业点）**
    - 循环的定义
        - 定义，流图中满足以下性质的节点序列（合取）：
            - 强连通，即任二间有通路，通路上节点均属该序列；单节点有自回路
            - 有且仅一个入口
    - 循环优化方法（不要求算法，三种观察下）
        - 代码外提
            - 循环不变运算
            - 循环不变运算外提的条件
            - 代码外提算法
        - 强度削弱
        - 删除归纳变量（变换循环控制条件）
        - 算法步骤 von der 强度削弱과删除归纳变量

# 章十一 目标代码生成

- 任务：优化后的中间代码を语义等价的目标代码に变换。要求正确、易于实现、高效运行
- 11.1 代码生成器设计中的问题
    - 生丶器の输入：源程序中间代码、符号表
    - 输出（目标代码形式）：可执行的机器语言代码（绝对机器代码）、待装配的机器语言模块（可重定位机器语言程序）、汇编语言代码
    - 指令选择、寄存器分配、计算顺序
- 11.2 一个计算机模型：指令类型、运算符
- 11.3 简单代码生成器
    - 概念
        - 功能：依次把三地址中码转为目码；基本块范围内充分利用寄存器
        - 指令类型
        - 原则：尽量引用寄存器，少访问内存；已在寄存器的值尽量保存直到必须释放
    - 待用信息与活跃信息
        - `待用信息`：无再定值的下次引用
        - `活跃信息`：仍要引用
        - 计算：**初化据出，倒序左清右活**
            - 初化：符表に，待用皆`^`，出口活跃Y否则`^`
            - 倒序左清右活：每条四元式(i)A:=BopC，从出口到入口倒序，先左部符A的符表数据给四元式表，A符表置(^,^)，再左右操作数BC，符表数据赋给四元式表，BC符表置(i,Y)
    - 寄存器描述与地址描述：动态记录寄存器状态、变量当前值存放位置
        - `寄存器描述数组` `RVALUE`：空闲、已分配给某个、已分配给多个变量
        - `地址描述数组` `AVALUE`：R中、M中、R及M中
    - `寄存器分配算法` `GETREG(i:A:=BopC)`：输入四元式及待用活跃信息，输出存放A的R **Bか空か释**
        - 若B当前在Ri，RVALUE[ Ri]只有B，此外，或BA同一标识符，或B此后不活跃，返回Ri。
        - 若有空闲寄存器，选一个Ri返回之。
        - 从已分配选一个为Ri，使满足其变量同时在内存、或最远处引用、或不引用。返回前的处理：对RVALUE[ Ri]中每一个M
            - 若AVALUE[ M]没它，ST Ri, M
            - 若M是B，或是C且B也在Ri中，令AVALUE[ M]={M,Ri}，否则AVALUE[ M]={M}
    - 代码生成算法：对每个四元式(i)A:=BopC **Re算闪人死释存用**
        - GETREG 返回值给A
        - 用BC的AVALUE确定当前值存放位置，设为B'C'
        - 生成目代。B'非R要LD。若B'或C'是R，删AVAL B 或 C 中的 R
        - AVAL[ A]={R}, RVAL[ R]={A}
        - BC为(^,^)则释放其Rk
        - (处理完所有i后，对仅在R且出口活跃者加ST R,M)
- 11.4 寄存器分配（不讲）
- 11.5 DAG 的目标代码（不讲）

# 些问题

- 章二，一开始说语言定义有四个方面，后来讲到文法又说语言是文法产生句子的全体，这两处应该是用「语言」这个词表达了不同的概念。常说的「程序设计语言」之「语言」当指前者，而且自然语言也和前者更接近（吧）。但这门课出的题目里，一般指后者。又或者，这两者就是同一个概念，只是我领悟不到家。
