设计模式

CLC: TP311

Dewey 005.12

https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)

- https://github.com/liu-jianhao/Cpp-Design-Patterns
    - C++ 实现，不过写到多个文件了不太直观
- 图说设计模式 https://github.com/me115/design_patterns
    - 种类不全，不同于这个划分

此 23 种，又称 GoF (Gang of Four, 书之作者也) design patterns 。（5、7、11，三个奇数）
**TODO: 添加更加结合代码的例子**

- 创造型（5） | Creational Patterns：关注如何有效、优雅地**创建对象**
    - 单例 Singleton
        - 一个类只有一个实例
        - 例子：数据库连接池，确保整个应用程序共享同一个数据库连接，以提高性能和资源利用率。
    - 工厂方法 Factory Method
        - 定义一个接口，但让子类决定实例化哪个类。工厂方法将对象的创建延迟到子类
        - 每个工厂只生产一个产品Class
    - 抽象工厂 Abstract Factory
        - 每个工厂生产多个产品Class
    - 生成器（建造者） Builder
        - 将复杂对象的构建与其表示分离，步骤多，顺序灵活
    - 原型 Prototype
        - 通过复制现有对象来创建新对象，而无需知道其具体类。通常用于创建成本较高的对象，通过克隆现有对象可以更高效地创建新对象。
        - 例子：在图像编辑软件中，可以复制一个图层来创建新的图层，而不需要从头开始绘制。
- 结构型（7） | Structural Patterns：关注于对象的组合，即如何**组织对象**以实现新功能或提供新的接口
    - 适配器 Adapter
        - 允许接口不兼容的类协同工作，将一个类的接口转换成客户希望的另一个接口。
    - 代理 Proxy
        - 提供一个代理类，控制对另一个对象的访问，用于实现延迟加载、访问控制等。
    - 桥接 Bridge
        - 将抽象和实现解耦，允许它们可以独立变化。这有助于避免类爆炸问题。
        - 示例：考虑图形绘制，你可以有不同的形状（抽象）和不同的颜色（实现）。桥接模式允许你以不同的方式组合它们，而不必为每种组合创建新类。
    - 组合 Composite
        - 允许将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使客户端能够以统一的方式处理单个对象和组合对象。
        - 示例：在图形应用程序中，你可以有简单的图形对象（如圆、矩形）和复合图形对象（如组合的矩形和圆），它们都可以通过相同的接口进行操作。
    - 装饰器 Decorator
        - 动态地将责任附加到对象上，扩展其功能。装饰器模式是继承的替代方案。
        - 示例：在咖啡店中，你可以有不同种类的咖啡（例如，浓缩咖啡），然后通过装饰器为它们添加额外的配料（例如，牛奶、糖）。
    - 外观（门面） Facade
        - 提供一个高级接口，使系统更易于使用，同时将系统的复杂性隐藏在背后。
        - 示例：操作系统的图形用户界面（GUI）可能提供一个外观，它允许用户轻松访问各种功能，而无需了解底层操作系统的复杂性。
    - 享元 Flyweight
        - 用于共享大量具有相似性质的对象，以节省内存和提高性能。
        - 举个例子，假设你有一个文字处理应用程序，需要在文档中表示每个字符。如果为每个字符都创建一个独立的对象，那么将消耗大量内存。使用 "Flyweight" 模式，你可以将字符的字体、大小等共享状态提取出来，并让多个字符共享这些状态，从而节省内存。
- 行为型（11） | Behavioral Patterns：关注于**对象之间的通信和责任划分**
    - 观察者 Observer
        - 定义了一种一对多的依赖关系，使得当一个对象状态发生改变时，其所有依赖者都会收到通知并自动更新。
        - 示例：一个天气应用程序可以有多个观察者（例如，显示温度、湿度、气压的组件），它们都订阅了天气数据，当天气数据更新时，它们都会得到通知并更新自己的显示。
    - 策略 Strategy
        - 定义一系列算法，将每个算法封装起来，并使它们可以互相替换，使得算法的变化独立于客户端。
        - 示例：一个支付系统可以使用策略模式，根据客户的选择使用不同的支付方式（例如，信用卡、PayPal、银行转账等）。
    - 命令 Command
        - 将一个请求封装成一个对象，从而允许参数化请求、将请求排队、记录请求日志等操作。
        - 示例：一个遥控器可以使用命令模式，其中每个按钮代表一个命令，按下按钮会执行相应的命令（例如，打开电视、切换频道等）。
    - 状态 State
        - 允许对象在其内部状态发生变化时改变其行为，使对象看起来好像修改了其类。
        - 示例：一个自动售货机可以使用状态模式，其中每种状态（例如，有货、无货、投币中）都定义了不同的行为。
    - 中介者 Mediator
        - 用一个中介对象来封装一系列对象之间的交互，从而降低对象之间的耦合。
        - 示例：一个聊天应用程序可以使用中介者模式，中介者对象负责管理用户之间的消息传递，而用户对象不直接相互通信。
    - 模板方法 Template Method
        - 定义了一个算法的骨架，将一些步骤延迟到子类实现，从而使子类可以重新定义算法的特定步骤。
        - 示例：一个咖啡制作程序可以使用模板方法，其中包括煮水、冲泡、加料等步骤，而具体的咖啡种类可以由子类实现。
    - 职责链（责任链） Chain of Resposibility
        - 将请求的发送者和接收者解耦，并允许多个对象处理请求。
        - 示例：一个审批流程可以使用责任链模式，其中每个审批者可以决定是否批准请求，如果不批准，则将请求传递给下一个审批者。
    - 迭代器 Iterator
        - 提供一种顺序访问聚合对象元素的方法，而无需暴露其内部表示。
        - 示例：一个列表类可以使用迭代器模式，以允许客户端逐个访问列表中的元素。
    - 备忘录 Memento
        - 在不暴露对象内部结构的情况下，捕获并外部化对象的内部状态，以便将对象恢复到先前的状态。
        - 示例：一个文本编辑器可以使用备忘录模式，用户可以保存编辑器的历史状态并在需要时回到以前的编辑状态。
    - 访问者 Visitor
        - 允许为对象的不同类别添加新的操作，而无需修改这些对象的类。
        - 示例：一个图形编辑器可以使用访问者模式，其中不同的访问者可以实现不同的操作（例如，绘制、计算面积）并应用于图形对象。
    - 解释器 Interpreter
        - Interpreter パターンの基本的な考えは、定義された種類の問題を素早く解くために、**Compositパターン**を使って ドメイン固有言語（DSL）を実装することである。特化言語は汎用の言語よりも数倍から数百倍高速に問題を解ける場合が多い。
        - 使用例：データベースに特化した問い合わせ言語（SQLなど）、

体会：感觉思维很OOP，都关于对象

MVC：[为什么GOF的23种设计模式里面没有MVC？](https://blog.csdn.net/baoaoba9317/article/details/101509636)