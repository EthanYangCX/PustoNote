操作系统

операционная система, operating system, sistema operativo, système d'exploitation, オペレーティングシステム, ระบบปฏิบัติการ, Betriebssystem, hệ điều hành, 운영 체제（運營 體制）, ᠦᠢᠯᠡᠳᠦᠯ ᠦᠨ ᠰᠢᠰᠲ᠋ᠧᠮ (üiledül ün sist᠋ēm),үйлдлийн систем

# 章一 操系概述

- 操系の作用
    - 位置
    - 用户视角
        - 服务
        - 用户界面：命令、GUI、系调
            - 系统调用の过程
            - 系调の类型：进程控制、文件管理、设备管理、信息维护、通信、保护
        - 不同用户不同需求
    - 系统视角：资源分配器。有效而公平。
        - 资源类别：CPU时间、内存空间、IO设备、文件存储空间
- 操系의发展过程
    - 人工操作方式
    - 单道批处理阶段：出现了监督程序，常驻内存，OSの雏形。联机批处理、脱机批处理
    - 多道批处理阶段
    - 分时系统
    - 实时操作系统
    - 批处理、分时、实时は三种基本なOS类型
- 操系の主要功能
    - 定义
    - 目标
    - 基本功能：
        - 处理机管理：进程控制、进程同步、进程通信、调度（作业调度、进程调度）
        - 存储管理：内存分配、内存保护、地址映射、内存扩充（逻）
        - 设备管理：设备分配、缓冲管理、设备处理
        - 文件管理（软件资源管理）（文件系统）：文件存储空间管理、目录管理、读写和存取控制
- 操系の基本特性
    - `并发`
        - 并行乄并发
    - `共享`
        - 方式：互斥共享方式、同时访问方式
    - `虚拟`：一个物理实体映射为若干逻辑实体
    - `异步`
- 计算机硬件简介
    - `总线`
    - 现代计算机系统工作模式——`冯诺依曼体系结构`
    - 处理机的状态：区分OS代码和用户定义代码の执行
        - 系统中两类程序：用户程序、管理程序
        - CPU中增加一个模式位表示当前模式
            - `内核模式`か`管理模式`か处理机的特权级：此状态下处理机可以使用全部指令、全部系统资源
                - linux区分管理模式，特权少于内核
            - `用户模式`
        - 处理机状态の转换
            - 用户→内核：唯一途径は中断
            - 内核→用户：可通过设置PSW（程序状态字，在CPU中）
        - `特权指令`：能引起伤害的机器指令
            - 可执行的功能：允许和禁止中断、进程切换、操作对主存进行保护的寄存器、IO控制、定时器管理
    - 存储器：主要指内存/主存（main memory）。操作系统本身也要放到主存运行
        - の类型
            - `读写型存储器`か`随机访问存储器`（RAM）
            - `只读型存储器`（ROM）
                - 变型：PROM、EPROM、EEPROM、闪存（flash memory）（必须按块擦除）
        - 의层次结构
        - 存储访问局部性原理：提高存储系统效能关键点
            - `平均访问时间`（每级存储器发现概率乘时间加和）
    - 时钟
        - `绝对时钟`（记录当前时间）、`间隔时钟`（通过时钟寄存器，到时触发时钟中断）
    - 中断技术：操作系统是由中断驱动的
        - 概念：CPU对系统中或外发生的异步事件的响应
        - 目的
        - 特点：随机、自动处理
        - 中断类型
            - 按中断功能分类
                - 输入输出中断
                - 外中断：¿通信中断とは？
                - 机器故障中断
                - 程序性中断
                - 访管中断
            - 按中断方式分类
                - 强迫性中断：如IO中断、外中断、机器故障中断、程序性中断
                - 自愿性中断
            - 按中断来源分类
                - 中断：处理机外部事件
                - 俘获：处理机内部事件
        - 中断系统的两大组成部分
            - 硬件中断装置
            - 软件中断处理程序
        - 中断装置の基本功能：源、态、保、址、构
        - `中断寄存器`：每源一触发器（`中断位`だ）寄存中断信号，触发器全体谓。
        - 发现中断：处理器の控制部件中有能检测中断な机构谓`中断扫描机构`，每条指令执行周期最后扫描中断寄存器
        - 中断响应：发现中断请求时中止现、引出中断处程
            - 硬件支持：指令计数器、处理机状态寄存器、系统堆栈、中断向量表
        - `中断向量表`：有的机器最低位1个字为之，每中断向量两个字。中断请求的设备接口向处理器发送设备在中向表の表目の编号
        - 中断优先级：一些机器，机器故障>程断和访断>外断>入出断
        - 中断屏蔽：可在PSW中设置中断屏蔽码屏蔽些类型，各设备接口也有中断禁止位以禁止彼
        - 中断处理一般过程：信、确、备（保PSW、PC、一些寄于系栈，切管模）、入（查表置PC）、始、环（上下文、态）、新（恢完PSW、PC）
        - 多个中断の处理：两种策略：
            - 种一：禁止中断，再次允许时再响应
            - 种二：允许高优打断低
        - 典型的中断处理
            - IO中断
                - 由IO设备控制器或通道
                - 类：正常、异常
            - 时钟中断
                - 维护软件时钟
                - 处理器时间调度
                - 控制定时任务
                - 实时处理
            - 硬件故障中断
                - 一般要做：保（保现，警）、评（高可靠环境中尽可能恢）
            - 程序性中断：指令出错、越权、越界，处理方法：
                - 法一：只能操系相关扩展功能模块完成。多为不能做的操作，如页面换入
                - 法二：程序自己完成。如算术运算错
            - 系统服务请求（自愿性中断）：处理器专用指令（访管指令）激发。现代一般不直接提供系调指令接口，而是应用层封装（API）或更高层的程序设计模板类和类库

思考题：

# 章二 进程管理

- 2.1 进程概念：描述程序在内存ﾅ运行状态，解决并发与共享带来的竞资、通信、协同
    - 相关概念
        - 进程乄程序：动态，独立运行的活动单位，竞争系统资源の基本单位。一程序可多进程。
        - 作业：批处理系统执行作业，生命周期长于进程
        - 进程是一个正在执行得程序的实例；程序的一次执行过程
    - 进程组成：内存中的进程包括代码段、数据段（含全局变）、栈、堆、PC、寄存器等
    - 进程特征：动态、并发、独立、异步
    - 进程状态：创建、运行、等待か阻塞、就绪、终止
    - 进程状态转换图：阻转就，就转运，运转俩
    - 进程控制块：进程存在的唯一标识，用户叵访，常驻内存
        - PCB主要内容：状态、PC、寄存、调度（优、队）、内存、记账、IO态
    - 进程调度：选择就转运。
        - 调度队列
            - 就绪队列
            - 等待队列，每个设备
            - 常用链表实现，头节点指首末
    - 进程队列图：展示各调度队列
    - CPU在进程间切换：由于中断或系调。要上下文切换。
    - 调度程序
        - 长期调度程序：即作业调度
        - 短期调度程序：CPU调度
        - 中期调度程序か交换（swap）：有些分时系统引入之，核心为可移除内存降低并发度
- 2.2 进程控制：pid唯一标识，父子创建成树
    - Linux 进程树
    - 父子进程的关系
        - 资源：共享所有 || 子共享父の部分 || 父子不共享
        - 执行：并发 || 父等待某或全子
        - 地址空间：相同程序数据（父の复制品也） || 装入另一个新程序
    - Linux进程创建
        - fork()建，对子进程返0，对父返子のpid，失败返负
            - 程序里以此判自己父或子
        - 子进程通过复制父の地址空间而成。通常一个进程使用exec()用新程序取代该进程地址空间
    - Win进程创建
        - 用CreateProcess()，需要将一个程序装入子进程地址空间
    - 进程终止
        - 原因：正常结束（调用exit()）、异常结束、外界干预（父可强终子）
        - 所有资源被OS释
        - 可返回状态值到父（通过wait()）
- 2.3 进程间通信（interprocess communication, IPC）：并发进程欲协作则要之以交换数据
    - 共享内存系统：胶粒协作进程皆可读写な共享内存区，驻留在创建它的进程的地址空间内，要向OS申请取消访他进程限制，的访问同步由协作进程负责
    - 消息传递系统：可用于不同机器
        - 直接通信方式：系统调用で直发
        - 间接通讯方式：邮箱で发收，箱可以为进程或OS所有
    - 其他通信方式
        - 管道（pipe）
            - 普通管道/匿名管道：单向，只用于父子
            - 命名管道：可双向，win的还可用于异机
        - 客服通信（Client/Server）
            - Socket通信：低级，无结构字节流を交换，由进程来解释
            - RPC（Remote Procedure Call）：交换的消息具有明确结构
                - RPC服务监听端口，消息包含函数标识及参数
- 2.4 线程：进程切换代价太高，故以线程为CPU调度基本单位。减少并发执行时空开销，并发性更好
    - 线程：又称轻量型进程，是进程内个相对独立的可执行单元。有线程控制块TCB，含线程ID、PC、寄、栈。与同进他线共享代码段、数据段、其他OS资源（打开的文件等）
    - 单线と多线程：同code, data, files;独reg, stack, PC
    - 服务器にの多线程：监听，新线程相应请求
    - 多线程の优点
        - 响应度高
        - 资源共享（通信简单）
        - 效率高（创建和调度）
        - 并发度高（进程可多核）
    - 多核并行
    - 线程池（thread pool）：进程开始时创建些线程，待用
        - 优点：比现建快；可限制可用线程数
        - 数量由CPU数量、内存大小、并发客户请求期望值，可动态调
    - VS2012 C++ 多线程编程
    - Java 多线程编程
- 2.5 处理机调度：实质是梳理机资源的分配。进程はIO密集型乄计算密集型，IO密应尽快得机会
    - 何时调度
        - 非抢占式调度（nonpreemptive）：主动放弃CPU
            - 当运转阻（IO或wait()）
            - 等终止
        - 抢占式调度（preemptive）：现代广泛
            - 当运转就（时钟中断）
            - 当阻转就（IO完或signal()唤。是否新就绪马上运行，取决于调度算法）
    - 调度准则
        - CPU使用率
        - 吞吐量：单位时间完成数
        - 周转时间：提交到完成
        - 等待时间：就绪队等待
        - 响应时间：请求到响应
    - 调度算法目标
        - 共同目标：公平、平衡、策略强制执行
        - 批处理系统目标——作业调度
            - 平均周转时间短
                - 带权周转时间：$周/运行时间$
                - 系统吞吐量高
                - CPU利用率
                - 指标有一定冲突，如SJF，吞吐高，长作业周转差
        - 分时（交互式）系统目标
            - 响应时间快
            - 均衡性：满足期望，不同操作不同期望
        - 实时系统目标
            - 保证截止时间
            - 可预测性
    - 算法
        - 先到先服务（FCFS, First-Come, First-Served）
            - 非抢占
        - 最短作业优先（SJF, Shortest-Job-First）：取决于下次CPU执行时间
            - 最小平均等待时间，吞吐量高
            - 困难在于如何知道下次执行时间（一般用于作业调度，用户提交时制定）
            - 抢占式的也称最短剩余时间优先调度
        - 轮转调度算法（RR, Round Robin）：基于时间片
            - 简单公平，常于分时
            - 就绪FIFO，类似FCFS而加抢占式切换
            - 时间片一般10~100ms
            - 平均等待时间较长（长于SJF短于FCFS）但响应快
            - 时间片一般为80%进程一次服务时间
        - 优级
            - RR假设优先级同，FCFS等待时间为优先级，SJF下次CPU执行时间的倒数优先级
            - 优先级确定
                - 静态优先级：重要性、费用、政治因素等人为
                - 动态优先级：一些测量数据，如内存专用、打开文件数、平均IO执行时间与平均CPU执行时间之比
            - （本课程用小整数表示高优）
            - 可以抢或非抢
            - 主要问题：低优先级「饥饿」
                - 解决——老化（aging）：定期增就绪队列排队进程の优先级
        - 多级队列：容易分组时，几个单独队列，按属性如内存大小、优先级、类型。各队调度算法可异。
            - 队列之间通常固定优先级抢占调度，也可以每个队列一定比例CPU时间。
            - 实时>系统>交互>批
        - 多级反馈队列
            - 普通多级队列开销小但不灵活。多馈允许进程在队列间迁移，占用CPU多的移低，低中等候多时移高。
                - 低优なの时片长
            - 最通用、最复杂
            - 特点：照顾了交互进程（优先级高）也照顾了计算密集型（时间片长）

问题：

- 如果进程刚开始需执行一段长时间，后又需要交互？

# 章三 进程同步

- 3.1 临界区问题
    - 生消
    - 临界区
- 3.2 进程同步方法
    - Dekker算法
    - Peterson算法
    - 屏蔽中断
    - 硬件指令
    - 改进的算法
    - 互斥锁变量
    - 信号量
        - 信号量の类型
        - の定义と实现
        - で互斥
        - で同步
        - の操作の讨论
    - 管程
        - の特性
        - 条件变量
        - 带条件变量の管程
- 3.3 典型的进程同步问题
    - 生消
        - 信号量で
        - 管程で
        - 管程のJava实现
    - 哲餐
        - 管程で
    - 读写
        - 模式一：读者优先
        - 模式二：公平竞争
        - 模式三：写者优先

# 章四 死锁

- 4.1 死锁概述
    - 资源
        - の使用顺序
    - 死锁の定义
    - 死锁の类型
    - 产生死锁の必条
    - 处理策略
- 4.2 死锁预防
    - 死锁预防
- 4.3 死锁避免
    - 安全状态
        - 举例
    - 银行家算法
        - の数据结构
        - 安全性算法
        - 资源请求算法
- 4.4 死锁检测与修复
    - 资源分配图
        - 化简
    - 死锁检测算法
    - 应用检测算法
    - 死锁恢复
    - 终止进程
    - 资源抢占

# 章五 内存管理

- 5.1 概述
    - 内存保护：`基址寄存器`、`界限寄存器`
    - `地址绑定`：每次都是从一个地址空间到另な映
        - 编译时绑定、加载时绑定、执行时绑定
    - 逻辑地址与物理地址
        - `逻辑地址`か`虚拟地址`：CPU所生
        - `物理地址`：内存单元所见（加载到内存地址寄存器）
    - `内存管理单元`（`MMU`）：逻辑地址を物理地址に。程序不见物址，引用时与基址寄存器（`重定位寄存器`）相加方可定位。
    - `动态加载`：所有程序以可重定位加载格式存于磁盘，主程序先加载到内存，其他模块在需要时再用`可重定位链接程序`加载，并更新程序的地址表。
    - `交换`（swap）：内存空间不够时进程从内存交换到外存。耗时。
        - 可以选择换出后继续让缓冲区和IO交换数据（让设备控制器来控制），但缓冲区和进程内存以及进程自己的处理一定不能用了
- 5.2 连续内存分配：早期方案，已弃
    - 两个分区（partition）——`操作系统区`、`用户进程区`，每进程は连续な内存区域を
    - 按分区划分方式分类：
        - 固定分区：内存划为多个固定分区，可同大或不，每は一进程。
            - 在作业大小と频率已知时合适
        - 可变分区：建进程时按需分区。OS管 `已分配分区表`と`空闲分区表`（空闲区链表）
            - 事先设定阈值，某空闲区减申请小于阈值则整个分给。以免外部碎片を。
            - 空闲区搜索算法と碎片问题
                - `首次适应法`（first-fit）：第一个足够大空闲区。可从链表头开始找也可以从上次结束の下位（循环首次适应法）
                - `最佳适应法`（best-fit）：满足な最小な空闲区。
                - `最差适应法`（worst-fit）：最大な空闲区
                - 三种策略比较：首、佳的空间利用和执行时间更好，首比佳快
                - 碎片问题：外部碎片、内部碎片（分配到多余实际需求）
                - 解决碎片：紧缩（定期压缩）、阈值（减外增内）、允址不连（分段か页管理）
- 5.3 分段（segmentation）：支持按段的用户视图的内存管理方案。每个段连续内存，逻辑地址空间为一组段
    - 段：按程序自身逻辑关系划为几段
        - C/C++ 编译的程序：栈区（stack）、堆区（heap）、全局区か静态区（static）、文字常量区、程序代码区
    - `段表`：实现逻址转物址
        - 逻辑地址は<`段号`, `段内偏移`>
        - `段表寄存器`存放段表基址と段表长度，段表には一组段长と段基址。段号太大（＞段表长度）か段内偏移太大（＞段长）なら`越界中断`；否则，段表中凭段号找段基址，加偏量得。
- 5.4 分页（paging）内存管理方案
    - 固定大小な帧（frame，物理内存）、页（page，程序の逻辑地址空间）という块
        - 帧、页同大小，皆 $2^k$ 字节
        - 免外部碎片
    - 地址转换：CPU 产两部分（页号、页偏移）
    - 页表：逻址到物址
    - 页大小：太大浪费（每进程平均半页内碎）太小页表过长，常4~8KB
    - 页表在内存，寄存器为`页表基址寄存器`、`页表长度寄存器`在PCB中，切换只改它们
    - `快表`
        - CPU的cache中有`转换表缓冲区`（`TLB`，translation look-aside buffer），放在TLB中的部分页表谓快表
        - TLB中查找时，同时与所有条目比较，没找到再找内存并放入TLB
        - 有的在TLB条目中有ASID标识进程，则切换不需改TLB
    - 用页号在TLB找，找不到在页表找，得到页基址，加偏移量得物址
    - 共享页：共享内存通信的一种实现
    - 分级页表：页表再分页，一个顶级页表，分到最后的页面大小等于内存帧
        - 栗子：32位系统，页4KB，则逻辑地址空间一共有$2^{32}B/4KB = 2^{20} = 1M$页，取页表项大小4B，需要占4MB的页表装下所有表项，装个屁。
            - 改用多级，x级，使每个页表有一页大。每页表项$4KB/4B = 2^{10}$，则要x次方不小于总页数，即$(2^{10})^x ≥ 2^{20}$，解得$x ≥ 2$，需要两级分页。
            - 64位的话，$2^{64}B/4KB = 2^{52}$页，$(2^{10})^x ≥ 2^{52}$得到$x≥6$，我觉得是6级页表，课件说7级？？？
    - 页内地址因为是后几位，同时页长$2^k$，因此最后几位是页内偏移不会溢出。但页号会越界吗，要检查吗？？？
- 段页式：程序分段，每段分页
    - 逻址は段号、页号、页内地址。

些题

- 给页长、页表，画出地址变换图以由逻址定物址：（转成二进制比较清楚）分原为表偏，表号共表首寻帧号，帧号加偏移得物址

# 章六 虚拟内存管理

- 6.1 虚拟内存概述
    - 虚拟地址空间
    - 好处
- 6.2 请求调页
    - 交换空间の使用
- 6.3 页面置换
    - 需要页换な情况
    - 算法
        - FIFO
        - OPT
        - LRU
            - の实现方式
            - LRU近似算法
        - 第二次机会算法
        - 改进型始终算法
        - 页面缓冲算法
    - 全部置换と局部置换
    - 系统抖动
    - 缺页错误率

# 章七 磁盘管理

- 7.1 磁盘概述
    - 移动磁头的磁盘装置
    - 磁盘の性能
    - 结构
    - 格式化
- 7.2 磁盘调度
    - FCFS
    - SSTF
    - SCAN
    - C-SCAN
    - LOOK
- 7.3 磁盘连接
    - 主机连接
    - 网络连接
    - 云存储
    - SAN
- 7.4 RAID 结构
    - RAID级别

# 章八 IO 系统

- 8.1 IO系统概述
    - IO硬件
    - 典型的PC总线结构
    - 常用IO设备与接口速率
    - IO设备の特性
    - IO系统の基本功能
    - IO系统の层次结构
    - 各种模块之间な层次视图
    - 设备驱动程序の功能
    - CPU如何与控制器交互
- 8.2 设备控制
    - 设备控制器の组成
    - 轮询方式
    - 中断方式
        - IO中断方式分析
    - DMA方式
        - DMA控制器
        - DMA方式の工作流程图
        - DMA方式工作过程
        - DMA方式与中断な主要区别
    - IO通道方式
- 8.3 缓冲技术
    - を为何引入
    - 常用な
    - 单缓冲区
        - 工作示意图
    - 双缓冲区
        - 工作示意图
    - 环形缓冲区
    - 缓冲池

# 章九 文件系统

- 9.1 文件概述
    - 属性
    - 操作
    - 类型
    - 逻辑结构
    - 访问方法
    - 保护
    - 共享
        - 链接技术で
            - 硬链接
            - 符号链接
            - 硬乄符
        - 快捷方式
- 9.2 目录结构
    - 目录操作
    - 单级目录结构
    - 两级目录结构
    - 树形目录结构
    - 无环图目录
    - Linux系统目录结构
    - 文件路径名
- 9.3 文件系统实现
    - の数据结构
    - 内存中な文件系统结构
    - 目录の实现
- 9.4 磁盘空间分配
    - 连续分配实例
    - 链接分配
    - 链接分配变形——FAT
        - PAT分配实例
    - 索引分配
        - 实例
    - Unix/Linux分配方案
    - 空闲空间管理
- 9.5 文件系统实例
    - MBR
    - 硬盘引导过程
    - GPT
    - FAT
    - FAT32
    - 文件分配表FAT
    - FAT32目录项
    - 长文件名目录项
    - NTFS
        - の元文件
    - $Boot元文件
    - 文件记录
    - 文件属性
    - Ext3文件系统
    - Ext3存储布局
    - 数据块寻址
