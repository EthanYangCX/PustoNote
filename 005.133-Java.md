CLC: TP312JA

Java 是衆司主流語，故 Java 體系開發常用中間件與相關原理皆記於此。

參考資料

- [Snailclimb/JavaGuide](https://github.com/Snailclimb/JavaGuide)
- [itwanger/toBeBetterJavaer](https://github.com/itwanger/toBeBetterJavaer)

# § 数据结构 et Collection

Java 所謂集合即容器，在 `Collection`（下有 `List` `Set` `Queue` 等）et `Map` （存键值对而非单独元素也）二接口。

- Java tjy 基本数据类型 et id 范围
    - `自动装箱（Autoboxing）`和`拆箱（Unboxing）`是Java语言提供的一种便捷机制，用于在基本数据类型（如 int、char）和它们对应的包装类（如 Integer、Character）之间自动进行转换。
        - `XXXStream.boxed()`例：`Arrays.stream(myArr).boxed().collect(Collectors.toSet());`
- Java有嘅数据结构
    - 一、集合框架（Java Collections Framework）
    - 二、数组（Arrays）
    - 三、特殊用途的数据结构
    - 四、并发数据结构（java.util.concurrent 包）
    - 五、树和图（第三方库支持更多）
- 集合框架的概览：
- List
    - `ArrayList`与`LinkedList`的区别
- Set
    - `HashSet`与`LinkedHashSet`的区别
    - `TreeSet`
- Queue：实现此接口的有常见的 LinkedList（最常用，双端链表），PriorityQueue（堆），还有 ArrayDeque ConcurrentLinkedQueue LinkedBlockingQueue ArrayBlockingQueue PriorityBlockingQueue
    - 集合框架里还有双端队列 Deque、栈 Stack（继承自 Vector，在现代Java不推荐，推荐代以Deque）
- Map
    - `HashMap`的工作原理
        - 基本结构：
            - **数组**：HashMap 的底层是一个数组，数组中的每个元素被称为一个桶（bucket）。
            - **链表**：每个桶中存放的可能是一个链表，用于处理哈希冲突。
            - **红黑树**：在 Java 8 及以后，为了提高性能，当链表长度超过一定阈值时（默认是 8），链表会转换成红黑树，以提高查找效率。
    - HashMap的扩容原理
    - `LinkedHashMap`：类似HashMap但维护键值对的插入顺序
    - `TreeMap`
    - HashMap与Hashtable的区别
    - 为什么HashMap不是线程安全的
    - ConcurrentHashMap：并发控制
        - 是 java.util.concurrent 包（JUC）下的类
        - 特点
            - 线程安全：支持高并发下的安全操作
            - 高性能：相比于传统的 Hashtable 和 Collections.synchronizedMap，有更高的并发性能。
            - 无锁读取：大多数读取操作不需要加锁，从而提高了读取操作的并发性能。
        - 并发锁的内部实现
            - Java 7：分段锁
                - 每个 Segment 使用一个独立的 ReentrantLock 进行同步。只有访问不同分段的时候才能并发。
                - 因为当时没有轻量锁的条件，每个节点都加锁太重了，于是折衷
            - Java 8：节点锁，用 CAS 和 Synchronized
                - 采用 CAS 操作（Compare-And-Swap）和 synchronized 来控制并发，进一步提升性能。
                - 在并发扩容时，通过 synchronized 锁定特定桶，防止并发冲突。
        - 数据结构
            - 每个桶，在有红黑树之余还额外维护一个双向链表（就是每个节点既保存父 左子 右子，也保存前驱后继）。
                - 代码：TreeNode类，继承了Node类（普通链表桶类，自带next，故TreeNode只需多加 prev, parent, left, right）
                - 多维护一个双向链表的作用：
                    - 1️⃣可以在正在写的桶上进行读操作。如果只有红黑树，此读操作会被旋转干扰，无法进行；而有了双向链表，则读操作至少可以O(n)地遍历，至少不用被阻塞
                    - 2️⃣扩容时复制更快，减少锁的时间。因为链表可以单向遍历完，无需树的压栈/队列型遍历，故更快。
        - 主要方法和并发处理
            - put()：使用 CAS 来插入新值，如果桶已经被占用则使用 synchronized 锁定相应桶进行插入。
            - get()：无锁操作，只需一次 volatile 读取即可。
                - （因为volatile保证「可见性」，读的是主内存中的最新值）（当然其他操作也用了volatile。。。）
            - size()：采用分段计数的方式，减少全局锁的使用，提高效率。
                - 是说，只有插入和删除操作会带来size变化，而相关线程，先尝试更新总计数 baseCount，若发现此计数被占用（发生冲突），就每个线程从map的CounterCell[]数组里申请一个CounterCell计数器，它里面维护了一个long值，被此线程用来记录本地size变化；如果线程太多，map本体的CounterCell[]不够大了，就扩大之；每个线程维护的是自己操作带来的size变化值，操作完成后通过sumCount方法把ounterCell[]里的每个计数器各自加到总的 baseCount 身上。
            - 扩容操作：多个线程一起做数据迁移。几个部分：
                - 扩容触发条件：当负载因子超过阈值时触发扩容。
                - 初始化扩容：设置扩容标志位（sizeCtl），计算扩容戳记，创建新表。
                    - `扩容戳记（resizeStamp）`，用来确保所有线程进行的是同一个扩容，也不会重复进行（因为扩容后将会是新的戳记）。是基于当前容量和一个固定位移值计算得到，所以同一个初始容量计算出来同样的戳记。
                    - `扩容标志位（sizeCtl）`
                        - 扩容开始：生成扩容戳记并写入 sizeCtl，表示扩容操作的开始。
                        - 参与扩容：每个线程在参与扩容时（在完成这段迁移后），会减少 sizeCtl 的值，表示自己参与了扩容任务。
                        - 完成扩容：当所有任务完成后，最后一个完成扩容的线程会更新 sizeCtl，表示扩容完成。
                - 并发迁移：多个线程并发地迁移元素，通过 transferIndex 跟踪迁移进度，使用 synchronized 块确保桶内操作的线程安全。
                    - 开始扩容时会先计算好步长`stride`，也就是每个线程每次搬运多少数据；然后创建新数组；然后后续进程领取任务
                    - 领任务靠`transferIndex`，它初始等于老表长`n`（桶数），每个线程迁移时用CAS来把`transferIndex`减少一个`stride`的值，也就是最后stride个桶是它的任务；
                    - 任务完成时用CAS减少`sizeCtl`的值，判断自己是不是最后一个退出的（if sizeCtl 减少到扩容戳记左移后的值），最后一个退出的线程会进行大检查，一个索引一个索引地看看有没有索引被遗留，最后结束
                - 更新引用：迁移完成后，更新表的引用，将旧表替换为新表。
- 不可变类（Immutable Class）
    - 即：内部状态不可变，所有字段皆 `private final`，不提供方法 que 改状态
    - 何以构：1️⃣类声明为 `final`；2️⃣所有字段声明为 `private final`；3️⃣用 Constructor 初始化所有字段；4️⃣不提供方法 que 改状态；5️⃣字段若为可变对象，喺构造函数深拷贝之，返回以不可修改视图 `Collections.unmodifiableXXX`；
- 并发集合：
    - 并发集合（如ConcurrentHashMap）是线程安全的，可以在多线程环境中使用，无需额外的同步。
- 算法和排序：
    - `Collections`类提供了多种静态方法来操作集合，如排序（sort()）、查找（max()和min()）和反转（reverse()）、shuffle、replaceAll、rotate
- 泛型：把类型作为参数
    - 通配符：`? extends T` 和 `? super T`，以及通配符`?`本身
    - 界限的类型参数：上界限（如`<T extends SomeClass>`）或下界限（如`<T super SomeInterface>`）
    - 泛型擦除：运行时，泛型类型参数被擦除。泛型只存在于编译时。
        - 泛型擦除的设计是为了保持与Java早期版本的兼容性，同时提供编译时的类型安全。
- 数据结构
    - 红黑树
        - 是一种自平衡二叉搜索树（所以别忘了首先有左小右大），靠以下5个条件保持平衡
        - 条件（5个）（**左根右，根叶黑，不红红，黑路同**）
            - **每个节点要么红🟥，要么黑⬛️**
            - **根节点は黑⬛️**
            - **叶节点（NIL）は黑⬛️**
                - NIL是为便于计算而虚拟的节点，使每个节点都有两个子节点，若节点实际只有1个子节点就补1个NIL，实际0子节点则补2个NIL
            - **红🟥节点之子节点必须为黑⬛️**（即不可连红🟥🟥）
            - **从任意节点到其每个叶子的路径都有相同数量的黑⬛️节点**
        - 五条件如何维平：叶子最短高度为全黑路径 `bh`（black height），最长为黑-红交替路径 `2 * bh`，故差距维持在此2倍内。`h_min = log(n + 1)` `h_max <= 2 * log(n + 1)`。即高度维持在 $O(log n)$ 范围内。
        - 乄AVL树
            - 对比：AVL树限制高度差为 0 或 1。更严格，使得平衡算法更繁琐，旋转操作次数更多也。
            - 由于旋转次数更少，修改操作更高效，故实际应用喜欢红黑树
            - 插入操作：红黑树可能需要0次旋转，1左或右旋转，或者2次旋转分别1左1右或1右1左。而AVL最坏情况需要 log(n) 次旋转（多个节点失衡，沿着插入/删除路径多次旋转）。
            - 删除操作：红黑树可能需要0〜3次旋转。而AVL最坏情况需要 log(n) 次旋转。
        - 平衡算法：重新着色、旋转
            - （正经面试遇到手写红黑树的话，可以直接拒掉，然后继续回家随便看一遍这套算法。。。）
            - 插入：新插入节点为红色（因为插黑色必违反「黑路同」，更棘手）。若此插入违反规则，则如下更改：
                - 插入的是根节点：直接变黑
                - 插入节点的叔叔是红色：父、叔、爷都变色，爷变成插入节点（继续判定）
                - 插入节点的叔叔是黑色：（LL（右旋）、RR（左旋）、LR（左旋左孩子然后右旋）、RL（右旋右孩子然后左旋））旋转，然后变色（把旋转点和旋转中心）
                - 「蓝不过海呀」大佬动画讲解 https://www.bilibili.com/video/BV1Xm421x7Lg
            - 删除
                - 和二叉搜索树一样，看要删除的节点的子：
                    - 若有两个子节点：则用直接前驱或后继代替之，转化为0/1个子节点
                    - 若只有左子树/右子树：直接代替。（按红黑树性质可知，只可能是父黑子红。）
                        - 然则，删掉父，用子代替父，然后子由红变黑即可
                    - 若没有孩子：直接删除之
                        - 若其为红：直接删除之
                        - 若其为黑： （删除后把它视为双黑节点）
                            - 若兄弟为黑
                                - 若兄弟至少有一个红孩子：（LL, RR, LR, RL）で变色（LL, RR 是侄变兄色，兄变父色，父变黑色；LR，RL是侄变父色，父变黑色 ）+旋转，然后双黑直接恢复成单黑
                                - 若兄弟孩子都黑：兄弟变红，双黑上移（即把问题转移到父节点；或者红色/根节点n变成双黑就直接作为单黑 ）
                            - 若兄弟为红：兄父变色，（父）朝双黑旋转（然后双黑仍在原位继续调整）
                - 「蓝不过海呀」大佬动画讲解 https://www.bilibili.com/video/BV16m421u7Tb
            - 增删查改的时间复杂度都是 log(n) 因为都要先找到。至于为什么说红黑树插入最多旋转2次，删除最多旋转3次，我先不找推导了。。。（好像是旋转不会继续向上传递）（但是着色可以是对数级别的）
- 算法
    - `Arrays.sort()`
        - 对基本数据类型，使用`双枢轴快速排序（Dual-Pivot QuickSort）`（by Vladimir Yaroslavskiy）
            - 双枢轴就是取两个 pivot，把数组排序成为小于 p1，介于二者，大于p2这三部分
            - 源码 https://hg.openjdk.org/jdk8/jdk8/jdk/file/tip/src/share/classes/java/util/DualPivotQuicksort.java
            - 第 282 行和 319 行左右的注释说明，取的两个枢轴是对 5 个值（中，以及中+seventh，中+seventh+seventh，中-seventh，中-seventh-seventh）排序后的第2第4个，也就是近似达到三分位的效果。（也就是近似 1.5/7 2.5/7 1/2 4.5/7 5.5/7 这5个位置比的，程序里叫 e1e2e3e4e5，比出来近似 2.5/7 4.5/7 两个位置，根本就规避了左右两端两个值。。。）
            - 当降级到单pivot时，取五者排序之中，即e3，即近似1/2者
        - 对对象数组，使用 `Timsort`，是一种混合排序算法，结合了归并排序和插入排序的优点。
            - 步骤
                - 寻找runs：扫描数组，寻找其中连续的有序子数组（run），若为降序则先转增
                - 扩展和合并runs（插入排序）：若发现的run长度小于某个阈值（常为32），则用插入排序扩展之使达到阈值
                - 归并runs（归并排序）：归并排序算法逐步合并这些runs，直到整个数组排序完毕
            - 利用插入排序在处理小规模和部分有序数据时的高效性，以及归并排序在处理大规模数据时的稳定性和高效性


```java
// List
// 创建列表
Arrays.asList("SIGN_OFF", "SIGN_ON")
// 声明
List<String> list;
// stream
if (list.stream().noneMatch(i -> i.getKey().equals(someElse))) {
        throw new ResponseStatusException(
            HttpStatus.BAD_REQUEST, "invalid someElse: " + someElse);
}
List<AForPublic> publicList = entityList.stream().map(
            x -> AConverter.INSTANCE.toAForPublic(
                    x,
                    aTypeService.get(x.getTypeKey()).getName(),
                    BConverter.INSTANCE.toBForPublic(bService.get(x.getBId()))
            )
    ).collect(Collectors.toList());
ates.sort(Comparator.comparing(AuditTrailEntity::getTimestamp, Comparator.reverseOrder()));

// String
// .substring()
// It throws IndexOutOfBoundsException If the beginIndex is less than zero OR beginIndex > endIndex OR endIndex is greater than the length of String.
"strawberries".substring(2, 5); // == "raw" ，跟python那样前闭后开
"strawberries".substring(6, 5); // 抛出异常
// String.equals() 用于比较内容相等，而 `==` 比较地址是否相等

// Boolean
// Boolean.parseBoolean("True") 将字符串参数解析为布尔值。 boolean返回的代表值为true 当字符串等于"true"，忽略大小写
Boolean.parseBoolean("True") // 返回true 。
Boolean.parseBoolean("yes") //返回false 。

// UUID
import java.util.Arrays;
Arrays.asList(UUID.fromString("0c312388-5d09-4f44-b670-5461605f0b1e")); // 个只含个UUID嘅列表

// Map<fromlichType, zulichType>

//
public interface xxx extends xxx2 {
    ;
}
```

## 集合（Collection, Map）

- [Java 集合常见知识点&面试题总结(上)](https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/collection/java-collection-questions-01.md)
- [Java 集合常见知识点&面试题总结(下)](https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/collection/java-collection-questions-02.md)

# § 他基 id-al basik konkept

- 变量
    - Java中的非基本数据类型的变量，都类似于C++的引用，是只指向对象的handler，而不是对象本身，亦不是指针。但这个引用不可变，即不可再指向别的对象。
        - **Java使用值传递（pass by value）还是引用传递**：使用**值传递**，但是由于Java的对象的变量不是对象本身而是一个“引用”，这里的“值”对于对象而言是引用的拷贝，但这个拷贝与原始引用都指向同一个对象。方法可以改变对象的状态，但不能改变参数副本的引用指向（使其指向另一个对象）。
            - 这样可以确保Java的安全性和可预测性，同时避免了直接的内存地址操作。
            - 就是说C++的「引用传递」可以让一个函数的参数比如 `foo (MyObj& ref)` 是个引用你可以让这个 ref 指向另一个对象（写一句`ref = newObj;`），然后你在外面调用 `MyObj outerRef = someObj; foo(outerRef);` 那么外部的这个 outerRef 就指向新对象了。（这就很复杂很难以预料对吧，可能someObj自此没有人引用它也没法回收它了） ；但Java的参数你让它指向新对象也不会改变外面使函数被调用的那个引用了。
- 面向对象
    - 基本概念：类与对象、封装、继承、多态
    - 访问控制修饰符：public, private, protected
    - 接口㐅抽象类 **接口与抽象类的区别**
        - 抽象类（Abstract Class），形如 `public abstract class Animal { ...`，用之 `public class Dog extends Animal { ...`
            - 抽象方法形如 `public abstract void eat();`，冇方法体
        - 接口（Interface），形如 `public interface Animal { ...`，用之 `public class Swan implements Flyable, Swimmable { ...`
            - 接口本身**可以继承多个其他接口**，`public interface Amphibious extends Flyable, Swimmable, Animal { ...`
            - 接口中，抽象方法形如 `void eat();` （接口中的方法默认是 public abstract）
        - 区别
            - （我觉得总之「类」是个东西，「接口」只是行为能力，这是设计上面核心的区别吧）
            - **继承**：单继承，多实现：类可以实现多个接口，但不可以继承多个类。
                - 可以一边继承一个类一边实现多个接口，形如 `public class Bird extends Animal implements Flyable, Walkable { ...`
            - **字段**：接口只能包含常量，默认`public static final`；抽象类可以含变量、多种访问修饰符
            - **方法**：接口所有方法皆不可有实现（Java8引入咗默认方法和静态方法），抽象类可以有
            - **实现**：实现所有接口方法：接口嘅方法皆抽象，皆须实现；但，iff声明一个类为抽象类，则可以不实现所继承的父抽象类中的抽象方法
                - 接口定义了一组方法，表示类必须实现嘅能力或契约（Contract），负责约束性；抽象类则负责灵活性
            - **构造方法**：接口冇，抽象类可以有构造方法，用于子类的初始化
            - 使用场景：接口：用于定义行为契约，不同类实现相同接口以保证行为一致性。抽象类：用于定义一组相关类的公共行为和状态，提供代码复用的基础。
    - **Java的继承与C++有何不同**（封装、继承、多台）
        - 单继承和多继承：Java单继承，而用接口实现多重继承效果；C++支持多继承。
        - 虚拟方法：Java中的（非静态、非私有、非最终final）方法默认是虚拟的（即可以被子类覆盖override）；C++需要使用virtual关键字e。
        - 接口和抽象类：Java通过接口实现多重继承，使用abstract关键字定义抽象类；C++通过虚拟继承和纯虚函数（=0）实现类似功能（定义纯虚函数者即抽象类）
        - 构造函数调用顺序：两种语言中父类构造函数都在子类构造函数之前调用，但调用方式不同。
        - 访问控制：Java和C++在protected成员的访问控制上，Java可以被同包嘅类与子类，C++可以被子类与友元
- 异常处理机制：try, catch, finally, throws
    - 异常类：皆继承自 `Throwable`，主要分 `Error` `Exception`
        - `Error`：表示编译时和系统错误（如OutOfMemoryError、StackOverflowError），通常不可恢复
        - `Exception`：可以在程序中被捕捉和处理的异常情况
            - `检查型异常（checked exceptions）`，即RuntimeException以外者，编译器要求处理。要么通过try-catch块捕获，要么通过throws关键字声明。
                - 它叫「检查」即编译器会「检查」佢是否被处理（捕获或声明）
                - 通常是由于外部因素或程序可以预见的情况导致的，所以可被检查，如IOException、SQLException
            - `非检查型异常（unchecked exceptions）`，即RuntimeException及其子类
                - 通常是由于编程或逻辑错误导致的，如NullPointerException、IndexOutOfBoundsException
                - 如果全都检查，就乱套啦、太冗余啦。每次数组调用都catch个越界错误？
    - try, catch, finally
        - finally块用于执行必须执行的清理工作，无论是否发生异常，finally块中的代码都会被执行
    - throws：声明此函数可能抛出异常
    - 异常链：一个异常导致一个异常
        - 可用`Throwable`类的`getCause()`方法获取原始异常。
    - 自定义异常
    - 断言：Java提供了assert关键字来进行调试，断言在运行时检查某个条件是否为真，如果为假，则抛出AssertionError。
- SPI：（Service Provider Interface）是 Java 的一种机制，让服务接口的定义和实现（服务提供者）解耦，然后在系统指定的目录下面，每个服务接口对应一个文件，里面记录各个服务实现类的全限定名，通过配置文件动态加载不同的实现。
    - 通过工具类 `java.util.ServiceLoader` 具体加载，此类可以.load()一个服务类的所有实现，可以遍历它来使用所有实现，遍历时可通过名字具体指定用哪个实现。
    - 实现模块化设计，动态加载也
    - 例如 JDBC API 中的 java.sql.DriverManager 类负责管理 JDBC 驱动程序，并且负责与数据库建立连接，其内部会使用 ServiceLoader 加载所有实现 java.sql.Driver 的类以注册，并以后在执行 getConnection() 时会遍历所有注册的 Driver，用第一个可以 driver.acceptsURL(url) 的 Driver 来连接

```java
// 方法重载（overload）：编译时的多态
// 方法重写（override）：运行时的多态

// try ... catch ... finally
// 其中 finally 不管是否有异常都会执行
// catch 捕捉其中一个后，后面的都不会catch
// 因此如果把范围大的写范围小的前面，编译会报错
// 下面这段程序会报错
import java.io.IOException;
public class ExceptionTryCatchTest {
    public void doSomething() throws IOException{
        System.out.println("do somthing");
    }
    public static void main(String[] args){
        ExceptionTryCatchTest etct = new ExceptionTryCatchTest();
        try {
            etct.doSomething();
        } catch (Exception e) {

        } catch (IOException e) {  // !!!这里报错

        }
    }
}
// Exception，Error 是 Throwable 的两大子类，catch Exception 的话对 Error 无效

// this 指向当前对象，super 指向最近的父类

// package
// 必须是第一条非注释语句。一个文件只有一个包。
// 可以无障碍使用包里的其他文件里定义的类。
package net.java.util; // 那么它的路径应该是 net/java/util/Something.java 这样保存的
public class Something{
   ...
}

// `@`: Java Annotation (注解)
// Java 注解只是检查、对比等工作（方法、类或变量）；而 Python 装饰器直接改变修饰的方法或类的功能。
@Override  //标记重写方法，在编译阶段对方法进行检查


// assert
assertTrue(roleTypeConfig.getRoleType("none").isEmpty());


// Test
@Test
...


// json：JavaScript Object Notation。
// json 里的属性名也是驼峰式地写。

// com.fasterxml.jackson... 包用以 java object 与 json
// deserialize 即 json 转 java对象
// json 里的属性名也是驼峰式地写。


// org.slf4j... 包是一个日志框架（Simple Logging Facade for Java）


// JavaBean
// c'est ett Klass specialeux, escripté de Java,
// die langgehen JavaBean API, d.h.
// - eine arg-less Konstrukter
// - getter, setter, isser
// - serializeble
// und sie'est in JSP <jsp:useBean> benutzbar


// JSP, nämlich Java Server Pages
// womit man insertiert Java Koden ins HTML Pagen

```

# § IO

# § 多线程 et 并发

- 线程概念
    - **线程与进程的区别**（&协程）
        - 核心
            - 进程（Process）是操作系统分配资源的基本单位
                - 进程独立拥有而线程共享之**资源**：内存空间（堆内存、全局变量）、文件描述符/句柄、代码段、数据段等资源
            - 线程（Thread）是进程的基本执行单位，共享进程之资源
            - 协程（Coroutine）协程是由程序本身调度的（用户态），不依赖操作系统（内核态）的线程调度
                - 每个协程自己嘅协程栈、协程上下文比线程嘅更加轻量
                - 协程和线程是多对多的关系，程序管理M个协程，并由具体的调度器（Dispatcher）确定运行时使用N个线程中的哪个运行。协程可以在线程之间切换哟。
        - 线程协程适用场景
            - 协程 适用于 I/O 密集型、高并发短时任务和轻量级任务调度等场景。
            - 线程 更适用于 CPU 密集型任务、需要真正并行执行的任务和硬实时系统等场景。
                - 主要就是协程不是底层所以不能控制并行计算，而线程更能充分利用多核处理器的优势？另外协程调度导致不可测的变化
            - 例如问法：线程与协程的区别，何场景用到协程
- 线程管理（生命周期与状态）
    - 线程创建方式（本质都是实现Runnable接口）
        - 实现Runnable接口
            - 然后传给Thread执行。如：
                - `Runnable myRunnable = () -> System.out.println("Runnable is running");`
                - `Thread thread = new Thread(myRunnable);`
                - `thread.start();`
            - 更推荐，因为与继承Thread相比不受单继承的限制。也更符合面向接口编程的设计原则。
        - 继承Thread类
            - 可以自己写一个类继承Thread并Override run()
            - 也可以直接把函数传给Thread的构造函数
                - `Thread thread = new Thread(() -> System.out.println("Thread is running"));`
                - `thread.start();`
            - Thread类的start()是真正启动线程，而run()是单线程运行
        - 使用Callable和Future
            - Callable本身不是线程，是一个普通接口，唯一抽象方法.call()有返回值、可抛出检查异常，把它送给Executor（线程池框架）会得到一个Future对象以获取返回值
            - `ExecutorService executor = Executors.newFixedThreadPool(2);`
            - `Callable<String> myCallable = new MyCallable();`
            - `Future<String> future = executor.submit(myCallable);`
        - （有时不答）使用线程池（Executor框架）
            - 与Callable方式的区别是这里可以直接使用Runnable
            - `Runnable runnable = new MyRunnable();`
            - `executor.execute(runnable);`
            - Lambda表达式可以直接表示单方法接口（函数式接口（Functional Interface），只有一个抽象方法）的实例，故也适用于Runnable（只有一个.run()），如：
                - `executor.execute(() -> System.out.println("Runnable task " + i + " is running"));`
        - 总结：不需返回值的任务就Runnable，需要返回值就Callable，需要线程池就交给ExecutorService
    - 线程的状态
        - 新建（New）：线程对象被创建，但尚未调用start方法。
        - 就绪（Runnable）：线程已经调用start方法，等待线程调度器分配CPU时间执行。Java的Runnable状态不区分“就绪”和“运行”。
        - 运行（Running）：线程获得CPU时间片，正在执行任务代码。Java中将这个状态包含在Runnable状态中，不单独区分。
        - 阻塞（Blocked）：线程在等待监视器锁，以便进入同步代码块或方法。通常因为尝试获取一个被其他线程持有的锁。
        - 等待（Waiting）：线程在等待另一个线程显式地唤醒。通常因为调用了Object.wait()方法或Thread.join()方法。
        - 超时等待（Timed Waiting）：线程在等待一定时间后会被自动唤醒。通常因为调用了Thread.sleep()方法、Object.wait(long timeout)方法或Thread.join(long millis)方法。
        - 终止（Terminated）：线程的执行已经结束，或者因为异常退出。
    - 线程的状态转换
        - 王道路线：NEW 者.start()则 RUNNABLE，得到处理器资源则 RUNNING，stop()或Exception或Error或run()/call()完成则 TERMINATED
        - RUNNING 者 yield() 或失去处理器资源（线程调度器）则 RUNNABLE
        - RUNNING 者 等待同步锁 则 BLOCKED，后者获取锁则 RUNNABLE
        - RUNNING 转 WAITING：调用Object.wait()方法、Thread.join()方法或LockSupport.park()方法，等待其他线程显式唤醒。
        - WAITING 转 RUNNABLE：线程被其他线程调用notify()、notifyAll()方法唤醒，或者等待的线程结束执行。
        - RUNNING 转 TIMED-WAITING：线程调用Thread.sleep(long millis)、Object.wait(long timeout)方法或Thread.join(long millis)方法，进入超时等待状态。
        - TIMED-WAITING 转 RUNNABLE：等待时间到达
    - 守护线程与用户线程（两种不同的线程种类）
        - 定义： 用户线程（User Thread）是默认的普通的线程，守护线程（Daemon Thread）是特殊线程，后台运行，用于提供服务或进行辅助任务。当所有用户线程都结束时，守护线程会自动终止，JVM也会退出。
        - 生命周期：只要有任何一个用户线程在运行，Java虚拟机（JVM）就不会退出。如果所有的用户线程都结束了，无论守护线程是否还在运行，JVM都会退出。守护线程会被强制终止（finally块不一定执行）。
        - 用途：用户线程，执行主要任务和业务逻辑。守护线程，执行后台任务或辅助任务，例如垃圾回收器（Garbage Collector）、日志记录、监控等。（不该执行重要任务，因为会随时终止）
        - 设置线程为守护线程：调用线程对象的setDaemon(true)方法。需在start前调用。
- 线程安全
    - 线程安全的定义
        - 线程安全是指多个线程访问共享资源时，能够正确地协调访问，避免竞态条件和数据不一致的问题。
    - 竞态条件与临界区
    - 同步机制（synchronized 关键字、显式锁（ReentrantLock 等））
    - `volatile` 关键字
        - 轻量级同步机制，确保变量的**可见性**和**有序性**
            - **可见性**：对 `volatile` 变量的写操作会立即刷新到主内存（而不仅是本地内存（线程缓存）），读操作会从主内存中读取。
            - **有序性**：`volatile` 变量的读写操作不会被重排序（底层概念，CPU或编译器优化的`指令重排序`）。
        - 实现原理：
            - 内存屏障（Memory Barriers 或 Memory Fences）
                - `写内存屏障`：在对 volatile 变量写入之前，插入一个写屏障，确保在写入之前的所有写操作都已完成。
                - `读内存屏障`：在从 volatile 变量读取之后，插入一个读屏障，确保在读取之后的所有读操作不会被重排序到读取之前。
                - 总结：就是一定在前面的代码之后才写，然后一定在其后的代码之前被读。好处之一比如把一个flag设为volatile，则可以确保前面操作完成后（写屏障）才会给flag设true，而if了flag为true（读屏障）后才会进行后续操作（不会提前读没改完的值）
                    - 例如写者有 `a = 42;` `flag = true;`；读者有`if (flag)` `int i = a;` 就能确保a被设置为42后才会读设 i = a
- 线程池
    - Java 中的线程池实现（Executor 框架）
    - 线程池的配置与使用
- Java内存模型和可见性问题
- 锁（线程锁（Thread Lock），乄分布式锁）
    - 锁的基础概念
        - 定义：控制多个线程访问共享资源的机制，防止并发访问引起的数据不一致。
    - 乐观锁乄悲观锁：锁的基本策略
        - 乐观锁（Optimistic Lock）
            - 定义：假设不会发生冲突，更新数据时才进行版本检查。适用于读多写少。
            - 实现方式：使用CAS（Compare And Swap）操作。（或者用版本号机制，也就是DB中多一个version字段，提交更新时读取判断是否版本和读取时一样，不一样就重试，一样再提交）
        - 悲观锁（Pessimistic Lock）
            - 定义：假设会发生冲突，每次访问数据时都会先加锁。适用于写多读少。
            - 实现方式：使用`ReentrantLock`或`synchronized`关键字。
    - 显式锁乄内置锁
    - 公平锁乄非公平锁
    - 各类锁的实现的说明
        - 独占锁（Exclusive Lock），也称为互斥锁（Mutex Lock）
            - 定义：一次只允许一个线程访问的锁。
            - 实现方式：`ReentrantLock`、`synchronized`
        - 共享锁（Shared Lock）
            - 定义：一次允许多个线程并发访问的锁，适用于读操作。
            - 实现方式：`ReadWriteLock`中的`readLock`
        - 可重入锁（Reentrant Lock）
            - 定义：允许同一个线程在获取到锁之后再次获取该锁。，避免递归调用或嵌套锁定导致的死锁问题。
            - 实现方式：`ReentrantLock`、`synchronized`
            - 相反地，不可重入锁在同一线程多次获取锁时会导致死锁问题，因此通常不用于Java并发编程中。
                - 就是说，同一个线程锁完一个资源后调用了一个内层方法，内层方法也需要这个锁住的资源。可重入锁使得这个原本线程可以在内层函数继续使用这个资源；不可重入锁则让它内层函数被死锁。
        - 读写锁（ReadWriteLock）
            - 定义：分为读锁和写锁，读锁是共享锁，写锁是独占锁。
            - 实现方式：`ReentrantReadWriteLock`
        - 自旋锁（Spin Lock）
            - 定义：线程在尝试获取锁时不会立即阻塞，而是通过不断循环检查锁的状态。
            - （也就是忙等待 busy wait）
            - 优点：
                - 减少线程上下文切换的开销。
                - 提高系统性能（多核处理器上充分利用并行能力，而不是阻塞在等待队列）。
                - 减少资源争用（在高并发环境下，频繁的线程阻塞和唤醒会导致对操作系统资源的频繁争用）
                - 适用于特定的并发场景：自旋锁适用于锁持有时间非常短的场景，比如在多核处理器上，临界区的代码执行时间非常短。在这种情况下，自旋等待比阻塞等待（如通过操作系统的同步原语）更有效率。
            - 缺点：在高并发下会导致CPU资源浪费。
            - 适用于锁时间短
        - 高级锁机制 - StampedLock
            - 定义：提供三种模式的锁：写锁、悲观读锁和乐观读锁。
            - 实现方式：`StampedLock`
            - 不可重入！！！
            - `long stamp = lock.tryOptimisticRead();` 之后 检查 if `lock.validate(stamp)` 就能知道有没有过更改，如果读取期间没有更改，就成功乐观读，否则程序员手动降级它为悲观读锁 `stamp = lock.readLock(); `，确保读取的正确性
        - 无锁 - CAS操作（Compare And Swap）
            - 支持以底层的硬件指令，因此是无锁的，由硬件本身保证操作的原子性。 `compareAndSet(expectedValue, newValue)`
            - 它由硬件支持，而不通过操作系统的锁，所以是在用户态，因此开销更小
            - 涉及的三个值：内存位置（Memory Location）、预期值（Expected Value）、新值（New Value）
            - 优点：避免使用锁的开销，提高并发性能。
            - 缺点：可能会出现ABA问题。
                - 解决ABA问题：添加版本号，使成为 1A 2B 3A；JDK 1.5 开始引入 Atomic 包的 AtomicStampedReference 实现这个解决
                    - `AtomicStampedReference` 是一种带有版本戳的引用类型，除了保存对象的引用外，还保存一个整数“标记”（stamp），用于记录对象的版本。当进行CAS操作时，除了比较对象的引用，还会比较这个整数标记，从而避免ABA问题。
            - 实现方式：原子类（Atomic Classes），在 `java.util.concurrent.atomic`
                - 包含：AtomicInteger、AtomicLong、AtomicBoolean、AtomicReference
    - （总结Java常用的锁的写法）
        - ReentrantLock
        - synchronized
        - ReentrantReadWriteLock
        - StampedLock
        - CAS 操作如 AtomicInteger
        - CountDownLatch、CyclicBarrier、Semaphore、Exchanger：这些并发工具类也提供了同步的功能，但不总是以传统锁的形式出现。它们是高级同步工具，用于特定的并发控制场景。
    - 线程间通信和锁的结合
        - 使用`Condition`：提供线程间协调通信的方法，与ReentrantLock结合使用。
    - 不是这里的线程锁：
        - 数据库的锁：间隙锁（Gap Lock）等锁是数据库里的锁，锁定索引种的间隙，防止幻读，详见DB
        - JVM中的锁优化机制：这些内容通常都是由Java虚拟机（JVM）自动管理和优化的，程序员不需要手动调用或显式地控制这些优化机制
            - 偏向锁（Biased Lock）
            - 轻量级锁（Lightweight Lock）
            - 自旋锁（Spin Lock）（这里是指 JVM 在底层优化 synchronized 块时的一个策略；另外程序员也可以手动写自旋锁）
            - 自适应自旋锁（Adaptive Spinning）
            - 锁消除（Lock Elision）
            - 锁粗化（Lock Coarsening）
            - 监视器锁（Monitor Lock）
            - 分段锁（Segmented Lock）
    - 我不知道怎么分类
        - 轻量
            - synchronized 关键字
                - 使用：
            - ReentrantLock
            - ReadWriteLock
            - StampedLock
        - 重量
            - synchronized 在高竞争情况下
            - ReentrantLock 的公平模式
        - 无锁
- 并发集合：ConcurrentHashMap, CopyOnWriteArrayList等

# § JVM

《深入理解Java虚拟机：JVM高级特性与最佳实践(第3版)》

- JVM执行步骤
    - **加载（Loading）**：将字节码文件（.class 文件）加载到内存中。
    - **链接（Linking）**：将加载的类与其他类进行链接，主要包括**验证、准备和解析**三个步骤。
    - **初始化（Initialization）**：初始化类中的静态变量和静态代码块。
    - 执行（Execution）：解释或编译字节码指令，执行Java程序。
    - 其中类加载机制：加载、链接、初始化
- 关键组成部分 de JVM
    - https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5
    - https://www.bilibili.com/video/BV1Q64y1h7PT
    - **类加载器（Class Loader）**
        - 负责加载、链接和初始化类。
        - 包括三种类加载器：引导类加载器、扩展类加载器和应用程序类加载器。
    - **运行时数据区（Runtime Data Area）**
        - **程序计数器（Program Counter, PC, pc Register）**：记录当前线程执行的字节码行号。
            - 很小以至于没有对应的OOM异常
        - **栈（Stack）**：每个线程都有一个独立的栈，存储局部变量和方法调用。以及对堆中的对象的引用。
        - **堆（Heap）**：存储对象实例，是垃圾回收的主要区域。
        - **方法区（Method Area）**：运行时常量池（public static final）和静态变量、类信息（类元数据）（反射机制就要用）等。
            - 乄元空间/永久代：方法区是JVM抽象的规范，而元空间（Metaspace，Java8以来，独立于堆 ）和永久代（PermGen，Java7及前，是堆空间的一部分）是对该抽象的具体实现。
                - 用元空间替代永久代的原因：
                    - 它内存更大，不易溢出，且可以动态调整大小，能加载更多的类元数据；
                    - 简化GC，因为永久代导致GC时类元数据都要被特殊处理和移动，改为元空间后GC专注回收对象
            - 是与堆不相连的本地内存区域，理论上系统内存多大，元空间就有多大 
        - **本地方法栈（Native Method Stack）**：用于执行本地方法。
            - 栈 de 本地方法，kue-est 其他语言编写的、交由Java运行的方法，使用`native`关键字描述
        - 关系：栈、本地方法栈、程序计数器三者属于线程自己。
        - 这五者也叫做JVM的内存结构。
    - **执行引擎（Execution Engine）**：负责执行字节码指令，包括解释执行和即时编译（JIT）。
        - **解释器**：逐行解释执行字节码指令。
        - **JIT编译器**：将热点代码（经常执行的代码）编译为本地机器码，提高执行效率。
    - **本地接口（Native Interface）**：提供与本地代码交互的接口（如JNI），允许Java调用非Java代码（如C/C++）。
- JVM 内存管理
    - **内存分配**：对象在堆中分配，局部变量在栈中分配。
    - **垃圾回收（Garbage Collection）**
        - 常见的垃圾收集器：Serial、Parallel、CMS、G1等。
        - 垃圾收集算法：标记-清除、复制、标记-压缩等。
- JVM内存模型（Java Memory Model, JMM）
    - 定义：是Java语言规范的一部分，定义了多线程环境下变量的读写操作规则，特别是共享变量在不同线程之间的可见性和指令重排序规则。
    - 目的：解决多线程环境下的内存可见性问题，确保不同线程之间的操作能够正确同步，并提供了一套规则来保证程序的执行顺序和内存一致性。
    - 关键概念
        - 可见性
        - 原子性
        - 有序性
    - JMM的规则和保障
        - volatile关键字
        - synchronized关键字
        - final关键字
    - **Happens-Before规则**：（我觉得每句话说Happens-Before还是略绕，因为before本义为之前，但描述的是前句发生在后句之前，前句发生之后才是后句。故「之后才是」更符合由前到后自然顺序，或者「然后有」之类的。）
        - **程序顺序规则**：一个线程内的操作按照代码顺序执行。
        - **监视器锁规则**：解锁操作 之后才是 此锁之加锁操作。
        - **volatile变量规则**：对一个volatile变量的写操作 之后才是 后续对这个volatile变量的读操作。
        - **线程启动规则**：线程的start()方法 之后才是 该线程的每一个动作。
        - **线程终止规则**：线程的所有操作 之后才是 其他线程检测到该线程终止。
        - **线程中断规则**：对线程interrupt()方法的调用 之后才是 被中断线程的代码检测到中断事件的发生。
        - **对象终结规则**：一个对象的构造函数执行结束 之后才是 该对象的finalize()方法。
- JVM的优化
    - 垃圾回收（Garbage Collection, GC）
        - 垃圾收集机制和垃圾收集器
        - 可达性分析（Reachability Analysis）：判断对象是否可以被回收的主要算法
    - 即时编译（Just-In-Time Compilation, JIT）
    - 逃逸分析（Escape Analysis）：逃逸分析用于确定对象的作用范围，如果对象不会逃逸出方法，可以在栈上分配内存而不是堆上，从而减少GC压力。
- JVM调优参数和工具
    - JVM 调优通常是通过设置 JVM 参数来实现的
    - **讲讲JVM启动时都有哪些参数**
        - 例：`java -Xms512m -Xmx1024m -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:+PrintGCDetails -Dfile.encoding=UTF-8 -jar myapp.jar`
            - 初始堆512M，最大堆1024M，使用 G1 垃圾收集器，最大 GC 暂停时间为 200 毫秒，打印 GC 详细信息，设置系统属性之文件编码为 UTF-8
        - 内存相关参数
            - 堆大小（Heap Size）设置
            - 非堆内存设置
            - 栈内存设置
            - 新生代和老年代（大小、比率）
        - 垃圾回收相关参数
            - 选择垃圾收集器
            - 垃圾收集器参数
        - JIT 编译相关参数：调整即时编译器参数，提高热点代码的执行效率。
            - 启用/禁用 JIT 编译器
            - 设置 JIT 编译器选项
        - 类加载调优：减少类加载次数，优化类加载路径。
            - 减少类加载次数：使用自定义类加载器，按需加载类。使用类加载缓存，避免重复加载相同的类。
            - 优化类加载路径
        - 调试和监控相关参数
            - 远程调试
            - JMX 监控
        - 其他常用参数
            - 系统属性
            - 日志和诊断

## JIT, Just-in-time compilation 即时编译

> 作者：lcksuper
> 链接：https://www.zhihu.com/question/21093419/answer/112968115
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
> 
> A JIT compiler runs **after** the program has started and compiles the code (usually bytecode or some kind of VM instructions) on the fly (or just-in-time, as it's called) into a form that's usually faster, typically the host CPU's native instruction set. A JIT has access to dynamic runtime information whereas a standard compiler doesn't and can make better optimizations like inlining functions that are used frequently.
> 
> This is in contrast to a traditional compiler that compiles **all** the code to machine language **before** the program is first run.
> 
> To paraphrase, conventional compilers build the whole program as an EXE file BEFORE the first time you run it. For newer style programs, an assembly is generated with pseudocode (p-code). Only AFTER you execute the program on the OS (e.g., by double-clicking on its icon) will the (JIT) compiler kick in and generate machine code (m-code) that the Intel-based processor or whatever will understand.

JVM 里面接受字节码的有两块：直接解释执行的 `Java Interpreter` 和将字节码转为 native (machine) code 的 `JIT compiler`。JVM 通过叫做`热点代码（hotspot code）`分析的技术来确定哪些代码编译成本地代码，热点代码通常是频繁执行的代码块（所以叫热点吧），例如循环或经常调用的代码；其他不太频繁执行的代码依然由解释器执行，因为编译成本地机器代码需要时间和资源，不适合所有代码。

与直接编译的语言如C相比，在运行期间收集一些数据以更好地优化代码（激进优化）也是JIT的优势之一。

## 垃圾回收

[JVM 垃圾回收](https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/jvm/jvm-garbage-collection.md)

内存分配和回收原则：

- 对象优先在 Eden 区分配
- 大对象直接进入老年代
- 长期存活的对象将进入老年代
- 主要进行gc的区域
- 空间分配担保

### Q: 什么分配到 Eden 什么分配到 Old Gen

随便看几个帖子：

- [JVM之堆内存（年经代，老年代）](https://www.cnblogs.com/shoshana-kong/p/9071004.html)
- [Java堆内存、新生代和GC](https://www.jianshu.com/p/da37c441b447)

堆分成两个区域：新生代 Young Gen，老年代 Old Gen

Young Gen 分成三个区域：Eden Space, From Survivor, To Survivor

[How is the java memory pool divided?](https://stackoverflow.com/questions/1262328/how-is-the-java-memory-pool-divided)

总结一下大家的说法应该是

- Heap Memory
    - Young Gen
        - Eden Space
        - Survivor Space
            - From
            - To
    - Tenured Generation or Old Gen
- Non-heap Memory
    - Permanent Generation
    - Code Cache  

新创建的对象分配到 Eden（除非太大直接到 Old Gen（或特殊处理？）（避免 Minor GC 时大量内存复制）），经过第一次 Minor GC 若仍存活则移动到 Survivor 区，Survivor 中每经过一次GC增加1岁，达到一定岁数就移动到 Old Gen。

Survivor Space：设置这个区域是个缓冲，因为直接送到 Old Gen 会让 Old Gen 增长太快，频繁触发开销更大的 Full GC

### Q: Minor GC, Full GC 的特点和区别？

Minor GC 是在 Young Gen 上面，Eden 的存活者复制到 To，From 的存活者中年龄到达阈值的移动到 Old，没到的复制到 To。如此则 Eden 与 From 已空。然后 From 与 To 交换角色：把 To 改为新的 From，原来的 From 作为 To。

Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。

Full GC 可能指对所有空间，也可能指对 Old Gen，好像有点混乱？

# § 各版本新特性

# § 缓存 et Redis

- Redis 各使用場景
    - **緩存**
        - **穿透、擊穿、雪崩**（緩存三兄弟）（三者嘅邏輯：冇key，單key，群key。皆大量请求直入DB之乱）
            - **緩存穿透**：查詢**不存在**之數據。因而查不到，不寫入緩存，每次皆查DB而慢。
                - 解方一：緩存空數據。優：簡單。缺：佔內存；可能不一致。
                - 解方二：布隆過濾器（Bloom Filter）。緩存預熱時先預Bloom；來請求先Bloom，存在纔可查Redis。
                    - 優：少佔內存，冇多餘key。缺：實現複雜，存在誤判。
                    - 原理：。位圖（bitmap）。N個hash函數，每id使這N位爲1，唔得則判其不存。
                    - 布隆過濾器實現方案：Redisson、Guava
            - **緩存擊穿**：某個key設咗過期時間，到期時恰好此key來大量併發請求，瞬間壓垮DB。
                - 解方一：互斥鎖。只一請求可進且更新redis，他請求退避
                    - 強一致，性能差（鎖需要等，亦可能死鎖）。
                - 解方二：邏輯過期。設過期時間字段，請求則返回之，程序知其過期，而不直刪於redis；另開一線程同步數據
                    - 高可用，性能優；不保證一致。
            - **緩存雪崩**：大量key同時失效，或者redis服務器宕機，導致大量請求DB
                - 解方一：給不同key之TTL加隨機值。（如1-5分，時間分散開）
                - 解方二：利用Redis集羣提高可用性。哨兵模式、集羣模式。
                - 解方三：給緩存業務添加降級限流策略。nginx或spring cloud gateway。
                    - **降級**可以做爲系統嘅保底策略，通用於此三兄弟
                - 解方四：添加多級緩存。Grava或Caffeine。
        - **雙寫一致、持久化**
        - **數據過期、淘汰策略**
    - **分佈式鎖**
        - **setnx**
        - **redisson**
    - **計數器** 
    - **保存token**（何種數據類型）
    - **消息隊列**（何種數據類型）
    - **延遲隊列**（何種數據類型）
- Redis 其他
    - **集羣**
        - **主從**
        - **哨兵**
        - **集羣**
    - **事務**
    - Redis 單線程但係快嘅原因
- 相关资料
    - 有意思的动画讲解视频 https://www.bilibili.com/video/BV1Fd4y1T7pD

# § DB et MySql

- SQL语句
    - 的编写
    - 优化
    - SELECT 语句执行流程
        - 解析（Parsing）
            - 词法分析：生成Token
            - 语法分析（Syntax Analysis）：确保符合SQL标准语法规则
        - 预处理（Preprocessing）：
            - 验证对象：检查 SELECT、FROM 的名字是否存在、有权
            - 语义检查：语句逻辑
        - 查询优化（Query Optimization）：生成查询树/图，查询优化器（Query Optimizer）生成多个查询计划，选择最优
            - 这一选择通常基于成本估算（如 I/O 操作、CPU 使用、网络延迟等）。
        - 执行计划（Execution Plan）：执行，其中应用索引
        - 数据检索（Data Retrieval）：读取数据，用 WHERE 过滤
        - 数据处理（Data Processing）：
            - 分组GROUP BY
            - 聚合函数（如 SUM、COUNT 等）
            - 排序ORDER BY
        - 结果集生成（Result Set Generation）
            - 投影：到SELECT指定的列
            - 去重：如果用了DISTINCT
        - 结果返回（Result Return） 
- 数据库的事务隔离级别
- 索引
    - 作用
    - 类型
        - 主键索引（Primary Index）：通过 PRIMARY KEY 关键字定义，用于唯一标识表中的每一行
        - 二级索引（Secondary Index）：通过 INDEX 或 KEY 关键字定义，用于在非主键列上创建索引，提高查询性能。
        - 唯一索引（Unique Index）：通过 UNIQUE 关键字定义，确保索引列中的值是唯一的。
        - 全文索引（Fulltext Index）：通过 FULLTEXT 关键字定义，用于加速对文本数据的搜索。
- **MVCC，多版本并发控制（Multiversion Concurrency Control）**
    - 允许多个事务在数据库中同时执行不相冲突。MVCC通过保存数据的多个版本来实现这一点。
    - 基本理解：保存老版本，使得读写并发时，读操作可以读老版本，而不是正在写的新版本，于是读不会被写阻塞：提高并发性能，避免锁的开销，但导致读到的不一定最新。
    - 两种读的方式对比
        - `快照读 (Snapshot Read)`：不被写操作阻塞。返回的不是正在写的最新版本，而是之前的版本，不受之后写操作影响
            - 例如：普通 SELECT 语句不显式加锁时
        - `当前读 (Current Read)`被写操作阻塞。确保数据最新。
            - 例如：SELECT ... FOR UPDATE 和 SELECT ... LOCK IN SHARE MODE 会显式加锁
    - MVCC具体实现涉及的三大组件
        - `三个隐式字段`：
            - 事务ID（Transaction ID）：`trx_id`，创建或更新该数据行的事务ID
            - 回滚指针（Rollback Pointer）：`roll_pointer`，指向Undo日志中的上一个版本，用于实现数据的回滚和多版本控制
            - 删除标志（Delete Flag）：标识数据行是否已被删除，但实际上并不会立即从数据库中移除
        - `Undo日志`：用于记录对数据行的每一次修改（插入、更新、删除）的前一个版本
        - `Read View（读视图）`：在快照读中，为事务提供一个一致性的快照，使在读操作期间，看到的数据不受其他事务的影响。
            - 含以下信息：
                - 活跃事务列表：创建Read View时正在活跃的所有事务ID。这些事务的修改对当前事务不可见
                - 最小活跃事务ID（`min_trx_id`）：活跃事务列表中最小的事务ID，表示在创建Read View时最早开始的活跃事务。
                - 最大事务ID（`max_trx_id`）：创建Read View时系统分配的下一个事务ID，表示所有ID小于此值的事务在Read View创建时已经存在。
            - 判断是否可见：
                - 数据版本的事务ID 小于 `min_trx_id`：创建视图时已提交，故可见
                - 数据版本的事务ID 大于等于 `max_trx_id`：视图创建后才开始的事务，不可见
                - 数据版本的事务ID 介于 `min_trx_id` 和 `max_trx_id` 之间：需要检查是否在活跃事务列表，在则尚未提交，不可见；不在则已经提交，可见
                    - （例如，一个事务 minID + 2可能在`min_trx_id`之后创建，但是 minID 的事务运行时间比较久，而此时 minID+2 可能已经提交了，故不在活跃事务列表中）
    - 具体运行过程：每次查询，先筛选出来需要的数据行，然后再逐一检查对此读操作的可见性
- MySQL
    - 引擎
        - InnoDB：适用于需要事务支持、高并发和外键约束的应用，是大多数应用的默认选择。
            - 使用 B+ 树作为索引数据结构
        - MyISAM：适用于读多写少的应用，如数据仓库和日志存储。
            - 使用 B+ 树作为索引数据结构
        - MEMORY：适用于需要快速访问的临时数据，如会话管理和缓存。
        - NDB：适用于需要高可用性和高扩展性的分布式应用。
        - ARCHIVE：适用于归档和长期存储不频繁访问的数据。
        - CSV：适用于数据交换和与外部系统的数据导入导出。
        - BLACKHOLE：适用于日志过滤和数据流控制。
        - Federated：适用于分布式数据库访问和跨数据库查询。
- 索引结构
    - 分类：
        - B树索引/B+树索引（笔记见下一节）
        - Hash索引：使用哈希函数将键映射到对应的值，适用于等值查询。Memory引擎（HEAP引擎）支持Hash索引，但不支持范围查询。
        - Full-Text（全文）索引：用于快速查找文本数据中的关键词，支持全文搜索功能。MySQL的InnoDB和MyISAM引擎都支持全文索引。
            - MySQL 会进行文本解析（tokenize、stopWords、词长）、倒排索引（Inverted Index）、TF-IDF以提供相关性评分
        - R-树（R-Tree）索引：适用于多维空间数据，如地理信息系统中的二维或三维数据。通常用于范围查询和近邻查询。
        - Bitmap索引：使用位图来表示数据，适用于数据分布相对较少、查询条件复杂的情况。常见于数据仓库和OLAP（联机分析处理）系统中。
        - GiST（Generalized Search Tree）索引
        - SP-GiST（Space-Partitioned Generalized Search Tree）索引
        - Trie（前缀树）索引
        - Inverted（倒排）索引
    - MySQL各引擎与索引结构
        - InnoDB 支持的索引
            - B+树索引：聚簇索引（Clustered Index）（顺序与主键相同，包含整行数据）、辅助索引（Secondary Index）（存储索引列和主键的组合）
            - 自适应哈希索引（Adaptive Hash Index, AHI）：InnoDB有一个自适应哈希索引机制，可以自动创建哈希索引来加速某些频繁访问的查询。这个哈希索引是由InnoDB引擎根据需要动态创建的，不是用户手动创建的。
            - 全文索引（Full-Text Index）：InnoDB支持全文索引，用于加速文本字段中的关键词搜索。这适用于较大文本字段的搜索操作，如MATCH和AGAINST查询。
                - MyISAM引擎在早期版本中对全文索引的支持更好，但从MySQL 5.6开始，InnoDB也增加了对全文索引的支持。
                - InnoDB 会将全文索引数据存储在其内部数据结构中，并通过事务机制来保证索引的一致性和可靠性。
            - 空间索引（Spatial Index）：InnoDB也支持空间索引，但支持是有限的。在较早的版本中，空间索引主要是MyISAM引擎的特性。但从MySQL 5.7开始，InnoDB也支持空间索引，这些索引用于GIS（地理信息系统）应用中的空间数据查询。
        - MyISAM 支持的索引
            - B+树索引：主键索引和辅助索引
            - 全文索引（Full-Text Index）
                - MyISAM 会将全文索引数据存储在专用的索引文件中，并使用 MyISAM 表的锁机制来管理并发访问。
            - 空间索引（Spatial Index）
        - Memory 引擎（也称为 HEAP 引擎），支持Hash 索引（等值查询，非常快速）和BTREE 索引（范围查询和顺序查询）
        - NDB Cluster 引擎：Hash 索引、BTREE 索引
    - 不同索引结构对一些操作的支持
        - 模糊查询：Hash索引无法模糊查询，因为只能用完整的键进行精确匹配；B+树索引支持一部分模糊查询，它不支持通配符在开头的模糊查询 `LIKE '%value'` ，但如果通配符在后面是支持的  `LIKE 'value%'` ，因为有序，可以匹配前缀
        - 多列索引的最左前缀匹配：Hash索引同样不支持因为必须完整的键：B+树索引支持，如果有一个复合索引 (a, b, c)，可以使用这个索引来查询 (a)、(a, b)、(a, b, c) 的组合。
- B树和B+树（常用索引结构）
    - 通用概念：
        - 阶：所有结点的孩子个数的最大值称为阶。通常用m表示
        - 终端结点（但是很多地方直接叫他叶子节点）：最后一排具有关键字的结点。
        - 叶子结点（常用性存疑）：也叫失败结点，没有任何信息的一排结点。 
    - B树
        - 也叫作多路平衡查找树、B-树。
        - 定义：
            - 每个结点最多有m棵子树。
            - 具有k个子树的非叶结点包含k -1个键。
            - 每个非叶子结点（除了根）具有至少 **⌈m/2⌉子树** ，即最少有 **⌈ m/2⌉-1个关键字** 。
            - 如果**根不是终端结点，则根结点至少有一个关键字**，即至少有2棵子树。【根的关键字取值范围是[1，m-1]，子树的取值范围是[2,m]】
            - 所有叶子结点都出现在同一水平，没有任何信息（高度一致）。【带有关键字那个叫做终端结点】
    - B+树
        - B+树是应数据库所需要而出现的一种B树的变形树。
        - 定义：
            - 每个结点最多有m棵子树。
            - 如果**根不是终端结点，则根结点至少有一个关键字**，即至少有2棵子树。【根的关键字取值范围是[1，m-1]】
            - **每个关键字对应一棵子树（与B树的不同）**，具有k个子树的非叶结点包含k 个键。
            - 每个非叶子结点（除了根）具有至少 **⌈ m/2⌉子树** ，即最少有 **⌈m/2⌉个关键字** 。
            - 终端结点包含全部关键字及相应记录的指针，叶结点中将关键字按大小顺序排序，并且相邻叶结点按大小顺序相互链接起来。
            - 所有分支结点（可以视为索引的索引）中仅包含他的各个子节点（即下一级的索引块）中关键字最大值，及指向其子结点的指针。
        - 特点（尤其是对比B树）
            - 多路性（Multi-way）：而非二叉
                - 高扇出（High Fan-out）：每个节点可以包含多个子节点（并且比B树更多）
                    - 也因此树高更低（与二叉树相比）
                    - 也因此拆分和合并的频率更低
            - 平衡：所有叶子节点都在同一层次，节点通过分裂或合并保持平衡
            - 所有数据存储在叶子节点
                - 内部节点不存数据，所以在遍历内部节点时内存可存更多节点，减IO
                - 也因此插入删除只需改叶子节点而更少重组内部节点，影响的节点数也更少，减复杂度和IO
            - 高效的范围查询：叶子节点通过链表相连
                - 因为B+树在叶子节点里面是顺序遍历，而B树想范围扫描的话要不停切换节点中序遍历，属于随机访问，磁盘等介质的顺序访问性能远高于随机访问。
            - 磁盘友好：啲特点适合磁盘
            - 对于锁定和并发访问的优势：
                - 内部节点只供导航，不存数据，故减少了锁定需求，大部分操作在叶子节点即可完成
                - 操作叶子节点时，只需要锁定相关叶节点和相邻节点，不需要锁定树，减少锁定范围
                - 范围操作时，可以按链表顺序锁定，避免来回跳转复杂锁定
                - 乐观并发控制：由于叶子节点是线性排列的，可以采用乐观并发控制策略，即先读取节点数据，在进行实际修改之前检查数据是否发生变化，如果没有变化则进行修改，从而减少锁定时间。
- 事务管理
    - 并发控制
        - 锁机制
            - 行锁（Row Lock）
            - 表锁（Table Lock）
            - 间隙锁（Gap Lock）
            - 意向锁（Intention Lock）

# § 框架 et Spring et MyBatis

- Spring 系列
    - Spring
        - 核心概念：IoC、AOP、MVC
        - Bean 线程安全问题
            - **单例的bean是线程安全的吗？**： 不是
                - 单例即默认嘅 `@Scope("singleton")` ，多例用 prototype
        - AOP et 事务（原理 et 事务失效）
            - AOP 常见场景：日志、缓存处理、spring内置事务
            - 事务本质用AOP实现
            - **事务失效嘅场景有：** 
                - 捕获异常而未抛出；
                - 抛出了检查（checked）异常；
                - 方法非public
        - Bean 的生命周期
            - 构造函数 ➡️ 依赖注入 ➡️ Aware 接口 ➡️ BeanPostProcessor#before ➡️ 初始化方法 ➡️ BeanPostProcessor#after ➡️ 销毁bean
        - bean循环引用
            - 解决以：三级缓存
                - 三级（singletonFactories），对象工厂，即早期引用
                - 二级（earlySingletonObject），早期bean对象，生命周期未走完
                - 一级（singletonObjects），单例，已经经历完生命周期、初始化完成
            - 解决以：构造函数上引用写 `@Lazy` 进行懒加载，即 `public A(@Lazy B b) { ... }`
        - Bean 的作用域
            - 定义如 `@Scope("singleton")`
            - 分类
                - singleton：IOC每次返回同一个Bean实例
                - prototype：IOC每次返回新的Bean实例
                - request（不常用）：仅对HTTP请求有效，每次HTTP请求创建新Bean
                - session：同一个session共享一个Bean实例
                - global-session（不常用）：所有session共享一个Bean
                - application（不常用）：整个Web应用范围共享Bean
    - SpringMVC
        - ：SpringMVC 是 Spring 的一部分，一个基于 Servlet 的 WEB 框架
        - 执行流程
    - SpringBoot
        - 自动配置原理
- MyBatis
    - 执行流程
    - 延迟加载
    - 一二级缓存
        - 一级，作用域系 session
        - 二级，作用域系 namespace 与 mapper
    - MyBatis与Hibernate的区别

# § 微服 et 分布式 et SpringCloud

- 高并发系统常见的三大策略：限流、缓存、熔断
- SpringCloud
    - 5大组件：
        - Eureka: 服务发现与注册
            - 替代：Nacos
        - Ribbon: 负载均衡
            - Ribbon 嘅各种负载均衡策略
        - Feign: 远程调用
        - Hystrix: 服务熔断
        - Zuul/Gateway: 网关
    - 具体理解一个用呢啲组件嘅项目：
        - eureka-server 同 gateway-service 作为单独嘅子目录，而其他3个（ribbon, feign, hystrix）不需要
            - 仲有 config-service/ 同 common/ 两个系公共嘅，其他子目录系各个微服务
    - 服务雪崩系咩，点算？
        - 啥：一个服务故障，使依赖佢嘅服务皆故障
        - 抓：
            - Hystix  服务熔断降级（解决）
                - 服务降级：提供备用嘅fallback响应
                - 服务熔断：暂时使唔可响应，一段时间后尝试允许一次请求，唔可则继续
            - 限流（预防）：防止突发流量导致系统崩溃
    - 监控
        - skywalking; Prometheus + Grafana; Springboot-admin; Zipkin
        - skywalking: 链路追踪，分布式追踪
        - Prometheus + Grafana: 时间序列数据的监控和可视化
- 业务相关
    - 限流
        - 限流的必要性：突发流量；恶意刷接口
        - 实现方式：
            - Tomcat：可设置最大连接数
            - Nginx，漏桶算法（Leaky Bucket Algorithm）
                - 漏桶以固定速率漏出（处理）请求，而超出桶容量嘅请求被抛弃（或等待）
                - 适用于：需要严格控制流量速率的场景，如网络传输速率控制。
            - 网关，令牌桶算法（Token Bucket Algorithm）
                - 桶容量固定，其中固定速率生成令牌，请求取到令牌方可处理，否则抛弃（或等待）
                - 特点：（令牌数量固定时）允许一定的突发流量（受令牌生成速率约束），更灵活，但实现较复杂
                - 适用于：需要既控制流量速率又允许突发流量的场景，如API请求限流。
                - 相关知识：Nginx服务器作为第一关（进行初步的限流、负载均衡等），API网关作为第二关（进行身份验证、授权、限流、熔断等），微服务系第三层（业务逻辑）
                    - Nginx以漏桶限流整体，网关以令牌桶给不同服务限流
            - 自定义拦截器
        - Nginx和网关限流实现
    - 分布式事务
        - 分布式事务理论：
            - CAP定理
                - ：分布式系统有呢三个指标，而无法同时满足：
                    - Consistency（一致性）：每节点一致
                    - Availability（可用性）：访问健康节点应得响应而非超时或拒绝
                    - Partition tolerance （分区容错性）：Partition（分区）指系统嘅一部份与其他失去网络连接而独立；分区容错指出现分区时仍提供服务
                - 分布式节点以网络连接，故一定有分区（P），有P时CA无法同时满足
            - BASE理论
                - BASE理论是对CAP的一种解决思路，包含三个思想：
                    - Basically Available （基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。
                    - Soft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态。
                    - Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。
            - 解决分布式事务的思想和模型：
                - 最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据（AP）
                    - 最终一致性的实现：
                        - 异步复制：更改先应用在一个节点，再复制出去
                        - 冲突检测和解决：
                            - 常见方法：
                                - 最后写入者胜出（Last Write Wins, LWW）：
                                - 向量时钟（Vector Clock）：追踪每个节点的更新历史，合并冲突的数据。
                                - 应用层解决：让应用层代码根据业务逻辑来解决冲突。
                        - 背景同步和修复：系统会定期在后台进行数据同步和修复
                            - 反熵算法（Anti-Entropy）：节点之间定期比较数据并进行同步，纠正不一致的部分。
                            - 读修复（Read Repair）：在读取数据时，如果发现不一致，会主动进行修复。
                        - 基于事件的架构：
                            - 通过发布和订阅模式，确保所有节点接收到相同的事件，并按照相同的顺序处理事件。
                    - 实例分析
                        - Amazon DynamoDB：异步复制+向量时钟+反熵算法
                        - Apache Cassandra：异步复制+时间戳（最后写入者胜出（LWW））+读修复
                - 强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚（CP）
        - 分布式事务框架：
            - Seata（包括XA、AT、TCC模式）
            - MQ分布式事务
    - 分布式服务接口幂等：（重复调用不应影响系统状态）
        - 幂等性设计的必要性及实现方式：
            - 数据库唯一索引
            - Token+Redis
            - 分布式锁
    - 分布式任务调度：支持任务的分片、重试和故障转移
        - XXL-Job的使用
            - 路由策略
            - 任务执行失败的解决方案
            - 大数据量任务的处理方式
    - 消息中间件：RabbitMQ、Kafka
- 分布式会话（session）管理
    - 可以通过：数据库、缓存、粘性会话（Sticky Sessions）（就是会话固定于一个节点，在负载均衡器（如 NGINX、HAProxy、Spring Cloud Ribbon）中配置）、共享文件系统、基于JWT令牌的无状态会话

# § 消息中件 et RabbitMQ et Kafka

- RabbitMQ
    - 消息不丢失
        - 生产者确认机制：确保消息成功发送到消息中间件并得到确认。
        - 消息持久化：确保消息在队列中的存储是持久的，防止数据丢失。
        - 消费者确认机制：消费者处理完消息后向中间件确认，确保消息被成功处理​​。
    - 消息重复消费
        - 使用唯一ID和幂等机制：每条消息设置唯一ID，通过分布式锁或数据库锁确保幂等性，防止消息重复处理​​。
    - 高可用机制
        - RabbitMQ：普通集群、镜像集群和仲裁队列来实现高可用​​。
        - Kafka：通过集群模式和分区备份机制实现高可用，多个broker实例提供服务，保证系统容错性​​。
    - 消息堆积
        - 当生产速度超过消费速度时，队列中的消息会堆积，RabbitMQ提供了惰性队列、增加消费者等解决方案​​。
    - 延迟队列
        - 使用死信交换机和TTL（生存时间）实现延迟消费，用于处理超时订单、限时优惠等场景​​。
    - 死信队列
        - 当消息无法被正常消费时，进入死信队列，以便后续处理​​。
    - RabbitMQ 五种工作模式
        - **简单队列（Simple Queue）**就是生产者消费者一对一；**工作队列（Work Queue）**就是一对多负载均衡；**发布/订阅（Publish/Subscribe）**就是多了一个属性叫交换机（Exchange），生产者们可以通过交换机名这个属性来使得只有订阅这个交换机的消费者收到消息；**路由（Routing）**就是在交换机下面又有多了个属性叫路由键（Routing Key），以做简单的分级，比如说severity的不同，使得订阅此交换机此分级的消费者才会处理；**主题（Topic）**模式就是在交换机下面多了个属性叫主题（Topic），消费者可以用通配符来匹配交换机的主题
- Kafka
    - 消息不丢失
    - 消息重复消费
    - 高可用机制
        - Kafka：通过集群模式和分区备份机制实现高可用，多个broker实例提供服务，保证系统容错性​​。
    - 高性能设计
        - 通过消息分区、顺序读写、页缓存、零拷贝、消息压缩和分批发送等技术提升性能​​。
    - 数据储存和清理
        - 采用分段存储结构和日志清理机制，根据消息保留时间或存储大小进行数据清理，提高磁盘利用率和查找效率​​。

# § 测试 et Mockito

- JUnit 单元测试框架

Mockito，生成模拟的对象。

```java
@BeforeMethod
void setUp() {
    pass;
}

@Test
public void testSomething() {
    // mock()

    // when().thenReturn()

    // doAnswer().when(someClass).someMethod()

    // als-Args-gegeben-zu-werdende Methoden:
    // eq(); any();


    // loe assertEquals()
    assertEquals(thing1, thing2);

    SomeException throwable =
        expectThrows(SomeException.class, () -> service.get(id));
    assertEquals(throwable.getStatus(), HttpStatus.NOT_FOUND);


    // loe verify() de Mockito
    // it's used to verify interaction's times, order, arg, etc.
    // 能验证的只能是 mock 的对象
    verify(someObj, times(1))
        .someMethod(eq(
            someThingInner
        ));
    verify(someObj, never()).someMethod(any());
}


```

# § 他具 id-al labor-instrum

- Maven或Gradle的使用
- Git的常用命令和工作流程

`BATIS` is a persistence framework which automates the mapping between SQL databases and objects in Java, .NET, and Ruby on Rails. In Java, the objects are POJOs (Plain Old Java Objects).

MyBatis

In software engineering, a p`lain old Java object (POJO)` is an ordinary Java object, not bound by any special restriction.

`JPA` 全称是 Java Persistence API，jpa 定义了各种注解（用来定义实体，映射关系）。JPA 仅仅是一个规范，它的实现比较出名的是 Hibernate。JPA 的函数定义方式

`Protocol Buffers`（简称：`ProtoBuf`）是一种序列化数据结构的协议。对于透过管道(pipeline)或存储资料进行通信的程序开发上是很有用的。这个方法包含一个接口描述语言，描述一些数据结构，并提供程序工具根据这些描述产生代码，用于将这些数据结构产生或解析资料流。

## Java 及 JDK 版本

Java8 发布于 2014，带来很多重要功能。近年 LTS 版本有 Java17 Java21 Java22。

Oracle JDK 自 Java 11 开始改变了授权协议，对于商业用途需要付费。但是，社区提供了多个开源的 Java 发行版本，如 AdoptOpenJDK（现在称为 Adoptium）、OpenJDK、Amazon Corretto 等，这些版本仍然可以免费商用。这意味着企业和开发者可以选择使用这些开源发行版而不需要支付许可费用。

## IntelliJ IDEA IDE

用免费版（CE）差唔多足够运行我嘅 maven 管理嘅 Spring Boot 项目？

## Gradle

Java 之 Gradle (et al.), Node.js 之 npm，Python 之 pip，皆包管理工具。

## Maven

`Apache Maven` ist ein auf Java basierendes Build-Management-Tool der Apache Software Foundation, mit dem insbesondere die Erstellung von Java-Programmen standardisiert verwaltet und durchgeführt werden kann.

- Maven versucht, den Grundgedanken „Konvention vor Konfiguration“ (englisch _Convention over Configuration_) konsequent für den gesamten Zyklus der Softwareerstellung abzubilden. Dabei sollen Softwareentwickler von der Anlage eines Softwareprojekts über das Kompilieren, Testen und Verpacken bis zum Verteilen der Software so unterstützt werden, dass möglichst viele Schritte automatisiert werden können. Folgt man dabei den von Maven vorgegebenen Standards, braucht man für die meisten Aufgaben des Build-Managements nur sehr wenige Konfigurationseinstellungen vorzunehmen, um den Lebenszyklus eines Softwareprojekts abzubilden.

## Spring

[A Comparison Between Spring and Spring Boot - Baeldung](https://www.baeldung.com/spring-vs-spring-boot)

> What Is Spring?
> 
> Simply put, the Spring framework provides comprehensive infrastructure support for developing Java applications.
> 
> It's packed with some nice features like Dependency Injection, and out of the box modules like:
>
> - Spring JDBC
> - Spring MVC
> - Spring Security
> - Spring AOP
> - Spring ORM
> - Spring Test
> 
> These modules can drastically reduce the development time of an application.

为 java 开发提供基础设施支持，有依赖注入等特性以及很多方便的模块

> 我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inversion of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。

**即 Spring 框架提供了 IoC、AOP 的支持以及许多其他模块，协助开发**

- IoC（控制反转，Inversion of Control）是一种理念，而 DI（依赖注入，Dependency Injection）是实现 IoC 的一种具体方法。
    - IoC，反转了传统的程序控制流程，控制权转移给框架或容器
        - 框架管理应用程序的组件及其依赖关系，应用程序各个部分不再负责自己的依赖项的创建和管理
    - DI，指将组件的依赖关系注入（传递）给组件
        - 具体方式：
            - 构造函数注入
            - 方法参数注入：在方法的参数上使用 `@Autowired` 注解。适合：依赖项只用于此方法而不是整个组件
            - 属性注入：在组件的属性上写注解 `@Autowired` 或 `@Resource`。要注意确保依赖项已注入，以防空指针异常
            - setter：可以给想注入的依赖项写个 `@Autowired public void setMyDependency(MyDependency myDependency) { this.myDependency = myDependency; }`

### Spring IoC Container

[5. The IoC container - Spring.io](https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html)

> IoC is also known as dependency injection (DI).
>
> -- [Spring.io](https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html)

[IoC容器 - 廖雪峰](https://www.liaoxuefeng.com/wiki/1252599548343744/1266265100383840)

> Spring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。

Spring IoC container 管理的对象（还是说组件？）称为 Bean

## Spring Boot

Spring Boot 是 Spring 的扩展，方便了开发、测试和部署。

- 有人说，四大组件分别是：starter， autoconfigure, CLI 以及actuator
- 消除了 XML 配置，而是用注解
    - 传统的 Spring 应用使用大量 XML 配置文件来定义 Bean、依赖关系、应用程序的行为
    - 约定优于配置（Convention over Configuration）
- Starter依赖项： Starter依赖项是预配置的依赖项集，用于快速添加特定功能，例如Web应用程序、数据库连接、消息队列等。通过添加Starter依赖项，您可以一键式地集成各种功能，而不必手动配置。
    - 也可以自定义 starter
- Autoconfigure（自动配置）：
    - > autoconfigure在我们的开发中并不会被感知，因为它是存在与我们的starter中的。所以我们的每个starter都是依赖autoconfigure的
    - > autocinfigure是starter体现出来的能力的代码实现
- CLI 是其命令行工具
- actuator 是其监视管理模块
- Spring Boot 内置 Web 服务器，默认使用 Tomcat，也可用 Jetty 或 Undertow 等

> Spring Boot is basically an extension of the Spring framework, which eliminates the boilerplate configurations required for setting up a Spring application.
> 
> It takes an opinionated view of the Spring platform, which paves the way for a faster and more efficient development ecosystem.
> 
> Here are just a few of the features in Spring Boot:
> 
> - Opinionated ‘starter' dependencies to simplify the build and application configuration
> - Embedded server to avoid complexity in application deployment
> - Metrics, Health check, and externalized configuration
> - Automatic config for Spring functionality – whenever possible

某开发实践

- entity 层：同 model 层，存放实体类，属性值同于数据库，提供 get、set
- dao 层（数据访问层）（后端用嘅数据）：即 mapper 层，对数据库进行持久化操作，他的方法是针对数据库操作的，基本用到的就是增删改查。它只是个接口，只有方法名字，具体实现在 mapper.xml 中。（可以写 SQL 语句的一些部分）
- service 层（业务逻辑层）（后端用嘅方法）：业务层，存放业务逻辑处理，不直接对数据库进行操作，有接口和接口实现类，提供 controller 层调用的方法。（里面的东西还是后端的类型。）
- controller 层（表示层）（前端用嘅方法）：控制器层，导入 service 层，调用 service 方法，controller 通过接收前端传过来的参数进行业务操作，在返回一个指定的路径或者数据表。（里面的东西转成前端的 request、response 等类型）
  总结：具体的一个项目中有：controller 层调用了 Service 层的方法，Service 层调用 Dao 层的方法，其中调用的参数是使用 Entity 层进行传递的。

简单理解其作用，可以帮我们把繁杂的那堆 http 请求自动解析、读取，转化为程序（比如在 controller 层）具体需要的信息。

[可能是最漂亮的 Spring 事务管理详解](https://blog.csdn.net/qq_34337272/article/details/80394121)

```java

```

在 Spring4.x 中增加了新的特性：如果类只提供了一个带参数的构造方法，则不需要对对其内部的属性写 @Autowired 注解，Spring 会自动为你注入属性。

### @Transactional

By default, Spring only roll back transactions for unchecked exceptions.

## Spring Cloud

在 Spring Boot 基础上集合了一系列框架，主要服务于微服务架构的软件的开发。

> Spring Cloud 是什么
> 
> - Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。
> - Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。

## OpenAPI

```java
// org.openapitools.codegen.languages.SpringCodegen
```

[OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator)
