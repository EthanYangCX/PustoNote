CLC: TP312JA

Java 是衆司主流語，故 Java 體系開發常用中間件與相關原理皆記於此。

參考資料

- [Snailclimb/JavaGuide](https://github.com/Snailclimb/JavaGuide)
- [itwanger/toBeBetterJavaer](https://github.com/itwanger/toBeBetterJavaer)

# § 数据结构 et Collection

Java 所謂集合即容器，在 `Collection`（下有 `List` `Set` `Queue` 等）et `Map` （存键值对而非单独元素也）二接口。

- Java tjy 基本数据类型 et id 范围
    - `自动装箱（Autoboxing）`和`拆箱（Unboxing）`是Java语言提供的一种便捷机制，用于在基本数据类型（如 int、char）和它们对应的包装类（如 Integer、Character）之间自动进行转换。
        - `XXXStream.boxed()`例：`Arrays.stream(myArr).boxed().collect(Collectors.toSet());`
- Java有嘅数据结构
    - 一、集合框架（Java Collections Framework）
    - 二、数组（Arrays）
    - 三、特殊用途的数据结构
    - 四、并发数据结构（java.util.concurrent 包）
    - 五、树和图（第三方库支持更多）
- 集合框架的概览：List, Set, Map等
- List
    - `ArrayList`与`LinkedList`的区别
- Map
    - `HashMap`的工作原理
        - 基本结构：
            - **数组**：HashMap 的底层是一个数组，数组中的每个元素被称为一个桶（bucket）。
            - **链表**：每个桶中存放的可能是一个链表，用于处理哈希冲突。
            - **红黑树**：在 Java 8 及以后，为了提高性能，当链表长度超过一定阈值时（默认是 8），链表会转换成红黑树，以提高查找效率。
    - HashMap的扩容原理
    - `LinkedHashMap`：类似HashMap但维护键值对的插入顺序
    - `TreeMap`
    - HashMap与Hashtable的区别
    - 为什么HashMap不是线程安全的
    - ConcurrentHashMap的并发控制
- Set
    - `HashSet`与`LinkedHashSet`的区别
    - `TreeSet`
- 不可变类（Immutable Class）
    - 即：内部状态不可变，所有字段皆 `private final`，不提供方法 que 改状态
    - 何以构：1️⃣类声明为 `final`；2️⃣所有字段声明为 `private final`；3️⃣用 Constructor 初始化所有字段；4️⃣不提供方法 que 改状态；5️⃣字段若为可变对象，喺构造函数深拷贝之，返回以不可修改视图 `Collections.unmodifiableXXX`；
- 并发集合：
    - 并发集合（如ConcurrentHashMap）是线程安全的，可以在多线程环境中使用，无需额外的同步。
- 算法和排序：
    - `Collections`类提供了多种静态方法来操作集合，如排序（sort()）、查找（max()和min()）和反转（reverse()）、shuffle、replaceAll、rotate
- 泛型：把类型作为参数
    - 通配符：`? extends T` 和 `? super T`，以及通配符`?`本身
    - 界限的类型参数：上界限（如`<T extends SomeClass>`）或下界限（如`<T super SomeInterface>`）
    - 泛型擦除：运行时，泛型类型参数被擦除。泛型只存在于编译时。
        - 泛型擦除的设计是为了保持与Java早期版本的兼容性，同时提供编译时的类型安全。


```java
// List
// 创建列表
Arrays.asList("SIGN_OFF", "SIGN_ON")
// 声明
List<String> list;
// stream
if (list.stream().noneMatch(i -> i.getKey().equals(someElse))) {
        throw new ResponseStatusException(
            HttpStatus.BAD_REQUEST, "invalid someElse: " + someElse);
}
List<AForPublic> publicList = entityList.stream().map(
            x -> AConverter.INSTANCE.toAForPublic(
                    x,
                    aTypeService.get(x.getTypeKey()).getName(),
                    BConverter.INSTANCE.toBForPublic(bService.get(x.getBId()))
            )
    ).collect(Collectors.toList());
ates.sort(Comparator.comparing(AuditTrailEntity::getTimestamp, Comparator.reverseOrder()));

// String
// .substring()
// It throws IndexOutOfBoundsException If the beginIndex is less than zero OR beginIndex > endIndex OR endIndex is greater than the length of String.
"strawberries".substring(2, 5); // == "raw" ，跟python那样前闭后开
"strawberries".substring(6, 5); // 抛出异常
// String.equals() 用于比较内容相等，而 `==` 比较地址是否相等

// Boolean
// Boolean.parseBoolean("True") 将字符串参数解析为布尔值。 boolean返回的代表值为true 当字符串等于"true"，忽略大小写
Boolean.parseBoolean("True") // 返回true 。
Boolean.parseBoolean("yes") //返回false 。

// UUID
import java.util.Arrays;
Arrays.asList(UUID.fromString("0c312388-5d09-4f44-b670-5461605f0b1e")); // 个只含个UUID嘅列表

// Map<fromlichType, zulichType>

//
public interface xxx extends xxx2 {
    ;
}
```

## 集合（Collection, Map）

- [Java 集合常见知识点&面试题总结(上)](https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/collection/java-collection-questions-01.md)
- [Java 集合常见知识点&面试题总结(下)](https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/collection/java-collection-questions-02.md)

# § 他基 id-al basik konkept

- 面向对象
    - 基本概念：类与对象、封装、继承、多态
    - 访问控制修饰符：public, private, protected
    - 接口㐅抽象类 **接口与抽象类的区别**
        - 抽象类（Abstract Class），形如 `public abstract class Animal { ...`，用之 `public class Dog extends Animal { ...`
            - 抽象方法形如 `public abstract void eat();`，冇方法体
        - 接口（Interface），形如 `public interface Animal { ...`，用之 `public class Swan implements Flyable, Swimmable { ...`
            - 接口本身可以继承多个其他接口，`public interface Amphibious extends Flyable, Swimmable, Animal { ...`
            - 接口中，抽象方法形如 `void eat();` （接口中的方法默认是 public abstract）
        - 区别
            - **继承**：单继承，多实现：类可以实现多个接口，但不可以继承多个类。
                - 可以一边继承一个类一边实现多个接口，形如 `public class Bird extends Animal implements Flyable, Walkable { ...`
            - **字段**：接口只能包含常量，默认`public static final`；抽象类可以含变量、多种访问修饰符
            - **方法**：接口所有方法皆不可有实现（Java8引入咗默认方法和静态方法），抽象类可以有
            - **实现**：实现所有接口方法：接口嘅方法皆抽象，皆须实现；但，iff声明一个类为抽象类，则可以不实现所继承的父抽象类中的抽象方法
                - 接口定义了一组方法，表示类必须实现嘅能力或契约（Contract），负责约束性；抽象类则负责灵活性
            - **构造方法**：接口冇，抽象类可以有构造方法，用于子类的初始化
            - 使用场景：接口：用于定义行为契约，不同类实现相同接口以保证行为一致性。抽象类：用于定义一组相关类的公共行为和状态，提供代码复用的基础。
    - **Java的继承与C++有何不同**
        - 单继承和多继承：Java单继承，而用接口实现多重继承效果；C++支持多继承。
        - 虚拟方法：Java中的（非静态）方法默认是虚拟的（即可以被子类覆盖；除非声明final）；C++需要使用virtual关键字。
        - 接口和抽象类：Java通过接口实现多重继承，使用abstract关键字定义抽象类；C++通过虚拟继承和纯虚函数（=0）实现类似功能（定义纯虚函数者即抽象类）
        - 构造函数调用顺序：两种语言中父类构造函数都在子类构造函数之前调用，但调用方式不同。
        - 访问控制：Java和C++在protected成员的访问控制上，Java可以被同包嘅类与子类，C++可以被子类与友元
- 异常处理机制：try, catch, finally, throws
    - 异常类：皆继承自 `Throwable`，主要分 `Error` `Exception`
        - `Error`：表示编译时和系统错误（如OutOfMemoryError、StackOverflowError），通常不可恢复
        - `Exception`：可以在程序中被捕捉和处理的异常情况
            - `检查型异常（checked exceptions）`，即RuntimeException以外者，编译器要求处理。要么通过try-catch块捕获，要么通过throws关键字声明。
                - 它叫「检查」即编译器会「检查」佢是否被处理（捕获或声明）
                - 通常是由于外部因素或程序可以预见的情况导致的，所以可被检查，如IOException、SQLException
            - `非检查型异常（unchecked exceptions）`，即RuntimeException及其子类
                - 通常是由于编程或逻辑错误导致的，如NullPointerException、IndexOutOfBoundsException
                - 如果全都检查，就乱套啦、太冗余啦。每次数组调用都catch个越界错误？
    - try, catch, finally
        - finally块用于执行必须执行的清理工作，无论是否发生异常，finally块中的代码都会被执行
    - throws：声明此函数可能抛出异常
    - 异常链：一个异常导致一个异常
        - 可用`Throwable`类的`getCause()`方法获取原始异常。
    - 自定义异常
    - 断言：Java提供了assert关键字来进行调试，断言在运行时检查某个条件是否为真，如果为假，则抛出AssertionError。

```java
// 方法重载（overload）：编译时的多态
// 方法重写（override）：运行时的多态

// try ... catch ... finally
// 其中 finally 不管是否有异常都会执行
// catch 捕捉其中一个后，后面的都不会catch
// 因此如果把范围大的写范围小的前面，编译会报错
// 下面这段程序会报错
import java.io.IOException;
public class ExceptionTryCatchTest {
    public void doSomething() throws IOException{
        System.out.println("do somthing");
    }
    public static void main(String[] args){
        ExceptionTryCatchTest etct = new ExceptionTryCatchTest();
        try {
            etct.doSomething();
        } catch (Exception e) {

        } catch (IOException e) {  // !!!这里报错

        }
    }
}
// Exception，Error 是 Throwable 的两大子类，catch Exception 的话对 Error 无效

// this 指向当前对象，super 指向最近的父类

// package
// 必须是第一条非注释语句。一个文件只有一个包。
// 可以无障碍使用包里的其他文件里定义的类。
package net.java.util; // 那么它的路径应该是 net/java/util/Something.java 这样保存的
public class Something{
   ...
}

// `@`: Java Annotation (注解)
// Java 注解只是检查、对比等工作（方法、类或变量）；而 Python 装饰器直接改变修饰的方法或类的功能。
@Override  //标记重写方法，在编译阶段对方法进行检查


// assert
assertTrue(roleTypeConfig.getRoleType("none").isEmpty());


// Test
@Test
...


// json：JavaScript Object Notation。
// json 里的属性名也是驼峰式地写。

// com.fasterxml.jackson... 包用以 java object 与 json
// deserialize 即 json 转 java对象
// json 里的属性名也是驼峰式地写。


// org.slf4j... 包是一个日志框架（Simple Logging Facade for Java）


// JavaBean
// c'est ett Klass specialeux, escripté de Java,
// die langgehen JavaBean API, d.h.
// - eine arg-less Konstrukter
// - getter, setter, isser
// - serializeble
// und sie'est in JSP <jsp:useBean> benutzbar


// JSP, nämlich Java Server Pages
// womit man insertiert Java Koden ins HTML Pagen

```

# § IO

# § 并发 et 多线程

- **线程与进程的区别**（&协程）
    - 核心
        - 进程（Process）是操作系统分配资源的基本单位
            - 进程独立拥有而线程共享之**资源**：内存空间（堆内存、全局变量）、文件描述符/句柄、代码段、数据段等资源
        - 线程（Thread）是进程的基本执行单位，共享进程之资源
        - 协程（Coroutine）协程是由程序本身调度的（用户态），不依赖操作系统（内核态）的线程调度
            - 线程嘅线程栈、线程上下文由其协程共享，而每个协程自己嘅协程栈、协程上下文比线程嘅更加轻量
- 线程的生命周期和状态
- 线程池的实现和使用
- Java内存模型和可见性问题
- 常见嘅锁
    - 轻量
        - synchronized 关键字
            - 使用：
        - ReentrantLock
        - ReadWriteLock
        - StampedLock
    - 重量
        - synchronized 在高竞争情况下
        - ReentrantLock 的公平模式
    - 无锁
        - 原子类（Atomic Classes），在 `java.util.concurrent.atomic`
            - 包含：AtomicInteger、AtomicLong、AtomicBoolean、AtomicReference
            - CAS（Compare And Swap）操作
                - 支持以底层的硬件指令。 `compareAndSet(expectedValue, newValue)`
- 并发集合：ConcurrentHashMap, CopyOnWriteArrayList等
- **线程与协程的区别，何场景用到协程**

# § JVM

《深入理解Java虚拟机：JVM高级特性与最佳实践(第3版)》

- JVM执行步骤
    - 加载（Loading）：将字节码文件（.class 文件）加载到内存中。
    - 链接（Linking）：将加载的类与其他类进行链接，主要包括验证、准备和解析三个步骤。
    - 初始化（Initialization）：初始化类中的静态变量和静态代码块。
    - 执行（Execution）：解释或编译字节码指令，执行Java程序。
    - 类加载机制：加载、链接、初始化
- 关键组成部分 de JVM
    - 类加载器（Class Loader）
    - 运行时数据区（Runtime Data Area）
        - 方法区（Method Area）
        - 堆（Heap）
        - 栈（Stack）
        - 本地方法栈（Native Method Stack）
        - 程序计数器（Program Counter, PC）
        - JVM的内存结构：堆、栈、方法区、程序计数器
    - 执行引擎（Execution Engine）：负责执行字节码指令，包括解释执行和即时编译（JIT）。
        - 解释器：逐行解释执行字节码指令。
        - JIT编译器：将热点代码（经常执行的代码）编译为本地机器码，提高执行效率。
    - 本地接口（Native Interface）：提供与本地代码交互的接口（如JNI），允许Java调用非Java代码（如C/C++）。
- JVM的优化
    - 垃圾回收（Garbage Collection, GC）
        - 垃圾收集机制和垃圾收集器
    - 即时编译（Just-In-Time Compilation, JIT）
    - 逃逸分析（Escape Analysis）：逃逸分析用于确定对象的作用范围，如果对象不会逃逸出方法，可以在栈上分配内存而不是堆上，从而减少GC压力。
- JVM调优参数和工具
    - **讲讲JVM启动时都有哪些参数**
        - 例：`java -Xms512m -Xmx1024m -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:+PrintGCDetails -Dfile.encoding=UTF-8 -jar myapp.jar`
            - 初始堆512M，最大堆1024M，使用 G1 垃圾收集器，最大 GC 暂停时间为 200 毫秒，打印 GC 详细信息，设置系统属性之文件编码为 UTF-8
        - 内存相关参数
            - 堆内存设置
            - 非堆内存设置
            - 栈内存设置
        - 垃圾回收相关参数
            - 选择垃圾收集器
            - 垃圾收集器参数
        - 调试和监控相关参数
            - 远程调试
            - JMX 监控
        - JIT 编译相关参数
            - 启用/禁用 JIT 编译器
            - 设置 JIT 编译器选项
        - 其他常用参数
            - 系统属性
            - 日志和诊断

## JIT, Just-in-time compilation 即时编译

> 作者：lcksuper
> 链接：https://www.zhihu.com/question/21093419/answer/112968115
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
> 
> A JIT compiler runs **after** the program has started and compiles the code (usually bytecode or some kind of VM instructions) on the fly (or just-in-time, as it's called) into a form that's usually faster, typically the host CPU's native instruction set. A JIT has access to dynamic runtime information whereas a standard compiler doesn't and can make better optimizations like inlining functions that are used frequently.
> 
> This is in contrast to a traditional compiler that compiles **all** the code to machine language **before** the program is first run.
> 
> To paraphrase, conventional compilers build the whole program as an EXE file BEFORE the first time you run it. For newer style programs, an assembly is generated with pseudocode (p-code). Only AFTER you execute the program on the OS (e.g., by double-clicking on its icon) will the (JIT) compiler kick in and generate machine code (m-code) that the Intel-based processor or whatever will understand.

JVM 里面接受字节码的有两块：直接解释执行的 `Java Interpreter` 和将字节码转为 native (machine) code 的 `JIT compiler`。JVM 通过叫做`热点代码（hotspot code）`分析的技术来确定哪些代码编译成本地代码，热点代码通常是频繁执行的代码块（所以叫热点吧），例如循环或经常调用的代码；其他不太频繁执行的代码依然由解释器执行，因为编译成本地机器代码需要时间和资源，不适合所有代码。

与直接编译的语言如C相比，在运行期间收集一些数据以更好地优化代码（激进优化）也是JIT的优势之一。

## 垃圾回收

[JVM 垃圾回收](https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/jvm/jvm-garbage-collection.md)

内存分配和回收原则：

- 对象优先在 Eden 区分配
- 大对象直接进入老年代
- 长期存活的对象将进入老年代
- 主要进行gc的区域
- 空间分配担保

### Q: 什么分配到 Eden 什么分配到 Old Gen

随便看几个帖子：

- [JVM之堆内存（年经代，老年代）](https://www.cnblogs.com/shoshana-kong/p/9071004.html)
- [Java堆内存、新生代和GC](https://www.jianshu.com/p/da37c441b447)

堆分成两个区域：新生代 Young Gen，老年代 Old Gen

Young Gen 分成三个区域：Eden Space, From Survivor, To Survivor

[How is the java memory pool divided?](https://stackoverflow.com/questions/1262328/how-is-the-java-memory-pool-divided)

总结一下大家的说法应该是

- Heap Memory
    - Young Gen
        - Eden Space
        - Survivor Space
            - From
            - To
    - Tenured Generation or Old Gen
- Non-heap Memory
    - Permanent Generation
    - Code Cache  

新创建的对象分配到 Eden（除非太大直接到 Old Gen（或特殊处理？）（避免 Minor GC 时大量内存复制）），经过第一次 Minor GC 若仍存活则移动到 Survivor 区，Survivor 中每经过一次GC增加1岁，达到一定岁数就移动到 Old Gen。

Survivor Space：设置这个区域是个缓冲，因为直接送到 Old Gen 会让 Old Gen 增长太快，频繁触发开销更大的 Full GC

### Q: Minor GC, Full GC 的特点和区别？

Minor GC 是在 Young Gen 上面，Eden 的存活者复制到 To，From 的存活者中年龄到达阈值的移动到 Old，没到的复制到 To。如此则 Eden 与 From 已空。然后 From 与 To 交换角色：把 To 改为新的 From，原来的 From 作为 To。

Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。

Full GC 可能指对所有空间，也可能指对 Old Gen，好像有点混乱？

# § 各版本新特性

# § 缓存 et Redis

- Redis 各使用場景
    - **緩存**
        - **穿透、擊穿、雪崩**（緩存三兄弟）（三者嘅邏輯：冇key，單key，群key）
            - **緩存穿透**：查詢**不存在**之數據。因而查不到，不寫入緩存，每次皆查DB而慢。
                - 解方一：緩存空數據。優：簡單。缺：佔內存；可能不一致。
                - 解方二：布隆過濾器（Bloom Filter）。緩存預熱時先預Bloom；來請求先Bloom，存在纔可查Redis。
                    - 優：少佔內存，冇多餘key。缺：實現複雜，存在誤判。
                    - 原理：。位圖（bitmap）。N個hash函數，每id使這N位爲1，唔得則判其不存。
                    - 布隆過濾器實現方案：Redisson、Guava
            - **緩存擊穿**：某個key設咗過期時間，到期時恰好此key來大量併發請求，瞬間壓垮DB。
                - 解方一：互斥鎖。只一請求可進且更新redis，他請求退避
                    - 強一致，性能差（鎖需要等，亦可能死鎖）。
                - 解方二：邏輯過期。設過期時間字段，請求則返回之，程序知其過期，而不直刪於redis；另開一線程同步數據
                    - 高可用，性能優；不保證一致。
            - **緩存雪崩**：大量key同時失效，或者redis服務器宕機，導致大量請求DB
                - 解方一：給不同key之TTL加隨機值。（如1-5分，時間分散開）
                - 解方二：利用Redis集羣提高可用性。哨兵模式、集羣模式。
                - 解方三：給緩存業務添加降級限流策略。nginx或spring cloud gateway。
                    - **降級**可以做爲系統嘅保底策略，通用於此三兄弟
                - 解方四：添加多級緩存。Grava或Caffeine。
        - **雙寫一致、持久化**
        - **數據過期、淘汰策略**
    - **分佈式鎖**
        - **setnx**
        - **redisson**
    - **計數器** 
    - **保存token**（何種數據類型）
    - **消息隊列**（何種數據類型）
    - **延遲隊列**（何種數據類型）
- Redis 其他
    - **集羣**
        - **主從**
        - **哨兵**
        - **集羣**
    - **事務**
    - Redis 單線程但係快嘅原因

# § DB et MySql

- SQL语句
    - 的编写
    - 优化
- 数据库的事务隔离级别
- 索引
    - 作用
    - 类型
- **MVCC，多版本并发控制（Multiversion Concurrency Control）**
    - 允许多个事务在数据库中同时执行不相冲突。MVCC通过保存数据的多个版本来实现这一点。

# § 框架 et Spring et MyBatis

- Spring 系列
    - Spring
        - 核心概念：IoC、AOP、MVC
        - Bean 线程安全问题
            - **单例的bean是线程安全的吗？**： 不是
                - 单例即默认嘅 `@Scope("singleton")` ，多例用 prototype
        - AOP et 事务（原理 et 事务失效）
            - AOP 常见场景：日志、缓存处理、spring内置事务
            - 事务本质用AOP实现
            - **事务失效嘅场景有：** 
                - 捕获异常而未抛出；
                - 抛出了检查（checked）异常；
                - 方法非public
        - Bean 的生命周期
            - 构造函数 ➡️ 依赖注入 ➡️ Aware 接口 ➡️ BeanPostProcessor#before ➡️ 初始化方法 ➡️ BeanPostProcessor#after ➡️ 销毁bean
        - bean循环引用
            - 解决以：三级缓存
                - 三级（singletonFactories），对象工厂，即早期引用
                - 二级（earlySingletonObject），早期bean对象，生命周期未走完
                - 一级（singletonObjects），单例，已经经历完生命周期、初始化完成
            - 解决以：构造函数上引用写 `@Lazy` 进行懒加载，即 `public A(@Lazy B b) { ... }`
    - SpringMVC
        - 执行流程
    - SpringBoot
        - 自动配置原理
- MyBatis
    - 执行流程
    - 延迟加载
    - 一二级缓存
        - 一级，作用域系 session
        - 二级，作用域系 namespace 与 mapper
    - MyBatis与Hibernate的区别

# § 微服 et SpringCloud

- SpringCloud
    - 5大组件：
        - Eureka: 服务发现与注册
            - 替代：Nacos
        - Ribbon: 负载均衡
            - Ribbon 嘅各种负载均衡策略
        - Feign: 远程调用
        - Hystrix: 服务熔断
        - Zuul/Gateway: 网关
    - 具体理解一个用呢啲组件嘅项目：
        - eureka-server 同 gateway-service 作为单独嘅子目录，而其他3个（ribbon, feign, hystrix）不需要
            - 仲有 config-service/ 同 common/ 两个系公共嘅，其他子目录系各个微服务
    - 服务雪崩系咩，点算？
        - 啥：一个服务故障，使依赖佢嘅服务皆故障
        - 抓：
            - Hystix  服务熔断降级（解决）
                - 服务降级：提供备用嘅fallback响应
                - 服务熔断：暂时使唔可响应，一段时间后尝试允许一次请求，唔可则继续
            - 限流（预防）：防止突发流量导致系统崩溃
    - 监控
        - skywalking; Prometheus + Grafana; Springboot-admin; Zipkin
        - skywalking: 链路追踪，分布式追踪
        - Prometheus + Grafana: 时间序列数据的监控和可视化
- 业务相关
    - 限流
        - 限流的必要性：突发流量；恶意刷接口
        - 实现方式：
            - Tomcat：可设置最大连接数
            - Nginx，漏桶算法（Leaky Bucket Algorithm）
                - 漏桶以固定速率漏出（处理）请求，而超出桶容量嘅请求被抛弃（或等待）
                - 适用于：需要严格控制流量速率的场景，如网络传输速率控制。
            - 网关，令牌桶算法（Token Bucket Algorithm）
                - 桶容量固定，其中固定速率生成令牌，请求取到令牌方可处理，否则抛弃（或等待）
                - 特点：（令牌数量固定时）允许一定的突发流量（受令牌生成速率约束），更灵活，但实现较复杂
                - 适用于：需要既控制流量速率又允许突发流量的场景，如API请求限流。
                - 相关知识：Nginx服务器作为第一关（进行初步的限流、负载均衡等），API网关作为第二关（进行身份验证、授权、限流、熔断等），微服务系第三层（业务逻辑）
                    - Nginx以漏桶限流整体，网关以令牌桶给不同服务限流
            - 自定义拦截器
        - Nginx和网关限流实现
    - 分布式事务
        - 分布式事务理论：
            - CAP定理
                - ：分布式系统有呢三个指标，而无法同时满足：
                    - Consistency（一致性）：每节点一致
                    - Availability（可用性）：访问健康节点应得响应而非超时或拒绝
                    - Partition tolerance （分区容错性）：Partition（分区）指系统嘅一部份与其他失去网络连接而独立；分区容错指出现分区时仍提供服务
                - 分布式节点以网络连接，故一定有分区（P），有P时CA无法同时满足
            - BASE理论
                - BASE理论是对CAP的一种解决思路，包含三个思想：
                    - Basically Available （基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。
                    - Soft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态。
                    - Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。
            - 解决分布式事务的思想和模型：
                - 最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据（AP）
                - 强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚（CP）
        - 分布式事务框架：
            - Seata（包括XA、AT、TCC模式）
            - MQ分布式事务
    - 分布式服务接口幂等：（重复调用不应影响系统状态）
        - 幂等性设计的必要性及实现方式：
            - 数据库唯一索引
            - Token+Redis
            - 分布式锁
    - 分布式任务调度：支持任务的分片、重试和故障转移
        - XXL-Job的使用
            - 路由策略
            - 任务执行失败的解决方案
            - 大数据量任务的处理方式
    - 消息中间件：RabbitMQ、Kafka

# § 消息中件 et RabbitMQ et Kafka

- RabbitMQ
    - 消息不丢失
        - 生产者确认机制：确保消息成功发送到消息中间件并得到确认。
        - 消息持久化：确保消息在队列中的存储是持久的，防止数据丢失。
        - 消费者确认机制：消费者处理完消息后向中间件确认，确保消息被成功处理​​。
    - 消息重复消费
        - 使用唯一ID和幂等机制：每条消息设置唯一ID，通过分布式锁或数据库锁确保幂等性，防止消息重复处理​​。
    - 高可用机制
        - RabbitMQ：普通集群、镜像集群和仲裁队列来实现高可用​​。
        - Kafka：通过集群模式和分区备份机制实现高可用，多个broker实例提供服务，保证系统容错性​​。
    - 消息堆积
        - 当生产速度超过消费速度时，队列中的消息会堆积，RabbitMQ提供了惰性队列、增加消费者等解决方案​​。
    - 延迟队列
        - 使用死信交换机和TTL（生存时间）实现延迟消费，用于处理超时订单、限时优惠等场景​​。
    - 死信队列
        - 当消息无法被正常消费时，进入死信队列，以便后续处理​​。
- Kafka
    - 消息不丢失
    - 消息重复消费
    - 高可用机制
        - Kafka：通过集群模式和分区备份机制实现高可用，多个broker实例提供服务，保证系统容错性​​。
    - 高性能设计
        - 通过消息分区、顺序读写、页缓存、零拷贝、消息压缩和分批发送等技术提升性能​​。
    - 数据储存和清理
        - 采用分段存储结构和日志清理机制，根据消息保留时间或存储大小进行数据清理，提高磁盘利用率和查找效率​​。

# § 测试 et Mockito

- JUnit 单元测试框架

Mockito，生成模拟的对象。

```java
@BeforeMethod
void setUp() {
    pass;
}

@Test
public void testSomething() {
    // mock()

    // when().thenReturn()

    // doAnswer().when(someClass).someMethod()

    // als-Args-gegeben-zu-werdende Methoden:
    // eq(); any();


    // loe assertEquals()
    assertEquals(thing1, thing2);

    SomeException throwable =
        expectThrows(SomeException.class, () -> service.get(id));
    assertEquals(throwable.getStatus(), HttpStatus.NOT_FOUND);


    // loe verify() de Mockito
    // it's used to verify interaction's times, order, arg, etc.
    // 能验证的只能是 mock 的对象
    verify(someObj, times(1))
        .someMethod(eq(
            someThingInner
        ));
    verify(someObj, never()).someMethod(any());
}


```

# § 他具 id-al labor-instrum

- Maven或Gradle的使用
- Git的常用命令和工作流程

`BATIS` is a persistence framework which automates the mapping between SQL databases and objects in Java, .NET, and Ruby on Rails. In Java, the objects are POJOs (Plain Old Java Objects).

MyBatis

In software engineering, a p`lain old Java object (POJO)` is an ordinary Java object, not bound by any special restriction.

`JPA` 全称是 Java Persistence API，jpa 定义了各种注解（用来定义实体，映射关系）。JPA 仅仅是一个规范，它的实现比较出名的是 Hibernate。JPA 的函数定义方式

`Protocol Buffers`（简称：`ProtoBuf`）是一种序列化数据结构的协议。对于透过管道(pipeline)或存储资料进行通信的程序开发上是很有用的。这个方法包含一个接口描述语言，描述一些数据结构，并提供程序工具根据这些描述产生代码，用于将这些数据结构产生或解析资料流。

## Java 及 JDK 版本

Java8 发布于 2014，带来很多重要功能。近年 LTS 版本有 Java17 Java21 Java22。

Oracle JDK 自 Java 11 开始改变了授权协议，对于商业用途需要付费。但是，社区提供了多个开源的 Java 发行版本，如 AdoptOpenJDK（现在称为 Adoptium）、OpenJDK、Amazon Corretto 等，这些版本仍然可以免费商用。这意味着企业和开发者可以选择使用这些开源发行版而不需要支付许可费用。

## IntelliJ IDEA IDE

用免费版（CE）差唔多足够运行我嘅 maven 管理嘅 Spring Boot 项目？

## Gradle

Java 之 Gradle (et al.), Node.js 之 npm，Python 之 pip，皆包管理工具。

## Maven

`Apache Maven` ist ein auf Java basierendes Build-Management-Tool der Apache Software Foundation, mit dem insbesondere die Erstellung von Java-Programmen standardisiert verwaltet und durchgeführt werden kann.

- Maven versucht, den Grundgedanken „Konvention vor Konfiguration“ (englisch _Convention over Configuration_) konsequent für den gesamten Zyklus der Softwareerstellung abzubilden. Dabei sollen Softwareentwickler von der Anlage eines Softwareprojekts über das Kompilieren, Testen und Verpacken bis zum Verteilen der Software so unterstützt werden, dass möglichst viele Schritte automatisiert werden können. Folgt man dabei den von Maven vorgegebenen Standards, braucht man für die meisten Aufgaben des Build-Managements nur sehr wenige Konfigurationseinstellungen vorzunehmen, um den Lebenszyklus eines Softwareprojekts abzubilden.

## Spring

[A Comparison Between Spring and Spring Boot - Baeldung](https://www.baeldung.com/spring-vs-spring-boot)

> What Is Spring?
> 
> Simply put, the Spring framework provides comprehensive infrastructure support for developing Java applications.
> 
> It's packed with some nice features like Dependency Injection, and out of the box modules like:
>
> - Spring JDBC
> - Spring MVC
> - Spring Security
> - Spring AOP
> - Spring ORM
> - Spring Test
> 
> These modules can drastically reduce the development time of an application.

为 java 开发提供基础设施支持，有依赖注入等特性以及很多方便的模块

> 我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inversion of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。

**即 Spring 框架提供了 IoC、AOP 的支持以及许多其他模块，协助开发**

- IoC（控制反转，Inversion of Control）是一种理念，而 DI（依赖注入，Dependency Injection）是实现 IoC 的一种具体方法。
    - IoC，反转了传统的程序控制流程，控制权转移给框架或容器
        - 框架管理应用程序的组件及其依赖关系，应用程序各个部分不再负责自己的依赖项的创建和管理
    - DI，指将组件的依赖关系注入（传递）给组件
        - 具体方式：
            - 构造函数注入
            - 方法参数注入：在方法的参数上使用 `@Autowired` 注解。适合：依赖项只用于此方法而不是整个组件
            - 属性注入：在组件的属性上写注解 `@Autowired` 或 `@Resource`。要注意确保依赖项已注入，以防空指针异常
            - setter：可以给想注入的依赖项写个 `@Autowired public void setMyDependency(MyDependency myDependency) { this.myDependency = myDependency; }`

### Spring IoC Container

[5. The IoC container - Spring.io](https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html)

> IoC is also known as dependency injection (DI).
>
> -- [Spring.io](https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html)

[IoC容器 - 廖雪峰](https://www.liaoxuefeng.com/wiki/1252599548343744/1266265100383840)

> Spring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。

Spring IoC container 管理的对象（还是说组件？）称为 Bean

## Spring Boot

Spring Boot 是 Spring 的扩展，方便了开发、测试和部署。

- 有人说，四大组件分别是：starter， autoconfigure, CLI 以及actuator
- 消除了 XML 配置，而是用注解
    - 传统的 Spring 应用使用大量 XML 配置文件来定义 Bean、依赖关系、应用程序的行为
    - 约定优于配置（Convention over Configuration）
- Starter依赖项： Starter依赖项是预配置的依赖项集，用于快速添加特定功能，例如Web应用程序、数据库连接、消息队列等。通过添加Starter依赖项，您可以一键式地集成各种功能，而不必手动配置。
    - 也可以自定义 starter
- Autoconfigure（自动配置）：
    - > autoconfigure在我们的开发中并不会被感知，因为它是存在与我们的starter中的。所以我们的每个starter都是依赖autoconfigure的
    - > autocinfigure是starter体现出来的能力的代码实现
- CLI 是其命令行工具
- actuator 是其监视管理模块
- Spring Boot 内置 Web 服务器，默认使用 Tomcat，也可用 Jetty 或 Undertow 等

> Spring Boot is basically an extension of the Spring framework, which eliminates the boilerplate configurations required for setting up a Spring application.
> 
> It takes an opinionated view of the Spring platform, which paves the way for a faster and more efficient development ecosystem.
> 
> Here are just a few of the features in Spring Boot:
> 
> - Opinionated ‘starter' dependencies to simplify the build and application configuration
> - Embedded server to avoid complexity in application deployment
> - Metrics, Health check, and externalized configuration
> - Automatic config for Spring functionality – whenever possible

某开发实践

- entity 层：同 model 层，存放实体类，属性值同于数据库，提供 get、set
- dao 层（数据访问层）（后端用嘅数据）：即 mapper 层，对数据库进行持久化操作，他的方法是针对数据库操作的，基本用到的就是增删改查。它只是个接口，只有方法名字，具体实现在 mapper.xml 中。（可以写 SQL 语句的一些部分）
- service 层（业务逻辑层）（后端用嘅方法）：业务层，存放业务逻辑处理，不直接对数据库进行操作，有接口和接口实现类，提供 controller 层调用的方法。（里面的东西还是后端的类型。）
- controller 层（表示层）（前端用嘅方法）：控制器层，导入 service 层，调用 service 方法，controller 通过接收前端传过来的参数进行业务操作，在返回一个指定的路径或者数据表。（里面的东西转成前端的 request、response 等类型）
  总结：具体的一个项目中有：controller 层调用了 Service 层的方法，Service 层调用 Dao 层的方法，其中调用的参数是使用 Entity 层进行传递的。

简单理解其作用，可以帮我们把繁杂的那堆 http 请求自动解析、读取，转化为程序（比如在 controller 层）具体需要的信息。

[可能是最漂亮的 Spring 事务管理详解](https://blog.csdn.net/qq_34337272/article/details/80394121)

```java

```

在 Spring4.x 中增加了新的特性：如果类只提供了一个带参数的构造方法，则不需要对对其内部的属性写 @Autowired 注解，Spring 会自动为你注入属性。

### @Transactional

By default, Spring only roll back transactions for unchecked exceptions.

## Spring Cloud

在 Spring Boot 基础上集合了一系列框架，主要服务于微服务架构的软件的开发。

> Spring Cloud 是什么
> 
> - Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。
> - Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。

## OpenAPI

```java
// org.openapitools.codegen.languages.SpringCodegen
```

[OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator)
