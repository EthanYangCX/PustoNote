CLC: TP312C++

书籍：

- **C++ Primer**, by Stanley B. Lippman; Josée Lajoie; Barbara E. Moo: 据说更经典。
    - 第5版，Originally published: 6 August 2012，根据 C++11 新标准，目前这本书比较够用
    - 本笔记计划基于这本书
    - https://zhjwpku.com/assets/pdf/books/C++.Primer.5th.Edition_2013.pdf
    - [如何正确通过 C++ Primer 学习 C++？ - Zhihu](https://www.zhihu.com/question/32087709)
- C++ Primer Plus, by Stephen Prata: 更入门，更适合编程经验少
- Effective ... 更进阶更优雅？

零散学习资料：

- https://en.cppreference.com/w/
- [isocpp/CppCoreGuidelines](https://github.com/isocpp/CppCoreGuidelines)
- [Microsoft C++、C 和汇编程序文档 - MSLearn](https://learn.microsoft.com/zh-cn/cpp/?view=msvc-170)
- [0voice/introduce_c-cpp_manual - GitHub](https://github.com/0voice/introduce_c-cpp_manual)
- [有哪些轻量级适合阅读的优秀 C++ 开源项目？ - 知乎](https://www.zhihu.com/question/40131963)
- 轮子哥的博客
    - http://www.cppblog.com/vczh/
        - [伴随我成长的编程书 - vczh](https://www.cppblog.com/vczh/archive/2016/03/28/198769.html)
    - https://cnblogs.com/geniusvczh/
- 叛逆者的博客 https://cnblogs.com/gongminmin/

[C/C++ for Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools)

# 1 开始

# 壹 C++ 基础

# 2 变量和基本类型

## 2.1 基本内置类型

## 2.2 变量

## 2.3 复合类型（类型加 `&` `*`。并收此符号比较）

- [What's the meaning of * and & when applied to variable names?](https://stackoverflow.com/questions/3350626/whats-the-meaning-of-and-when-applied-to-variable-names)

&nbsp;| 在变量声明前，作为类型之修饰 | 在变量前，作为变量一元操作
-|-|-
`&` | 表明其为引用类型 | 用于对象，取其地址
`*` | 表明其为引用类型 | 用于指针，取其内容（即，解引用 dereference）
`[]` | （不一定在前？在后表长度）表明其为列表类型 | 用于列表对象，取其列表成员

## 2.4 const 限定符

## 2.5 处理类型

## 2.6 自定义数据结构

# 3 字符串、向量和数组

# 4 表达式

# 5 语句

# 6 函数

# 7 类

# 贰 C++ 标准库

# 8 IO 库

# 9 顺序容器

是对第三章的拓展。

如 `vector<>`，可变长的序列也。

`.begin()` 是第一个元素的迭代器，`.end()` 是最后一个元素之后的元素

`.push_back(t)` 在尾部创建值为`t`的元素，`.push_front(t)`头部，`.inseart(p, t)`在`p`指向的元素前

# 10 泛型算法

# 11 关联容器（如 mapとset）

`关联容器`与`顺序容器`有根本不同：其元素按关键字来保存和访问，而不是按位置顺序。

标准库的8个关联容器：

名称|头文件|集合还是映射|是否允许关键字重复|按顺序保存元素还是无序
-|-|-|-|-
`map`|`<map>`|map|叵重|有序
`set`|`<set>`|set|叵重|有序
`multimap`|`<map>`|map|可重|有序
`multiset`|`<set>`|set|可重|有序
`unordered_map`|`<unordered_map>`|map|叵重|无序
`unordered_set`|`<unordered_set>`|set|叵重|无序
`unordered_multimap`|`<unordered_map>`|map|可重|无序
`unordered_multiset`|`<unordered_set>`|set|可重|无序

## 11.1 使用关联容器

## 11.2 关联容器概述

## 11.3 关联容器操作

## 11.4 无序容器

https://en.cppreference.com/w/cpp/container/unordered_map

`unordered_` 的元素，即 `unordered_map` 等。这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的`==`运算符。

# 12 动态内存

# 叁 类设计者的工具

# 13 拷贝控制（三五法则，拷构と移构と拷赋と移赋と析构，RAII）

## 13.+ RAII

RAII (Resource Acquisition Is Initialization)，资源获取即初始化。基本是说，凡资源，要在构造函数里获取，在析构函数里释放。

C++没有自带的垃圾回收机制，但关于避免内存泄漏等目的，RAII 这个规范大概是够用的？

- [Resource acquisition is initialization - Wikipedia](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization)
- [RAII - cppreference.com](https://en.cppreference.com/w/cpp/language/raii)
- [对象生存期和资源管理 (RAII) - MS Learn](https://learn.microsoft.com/zh-cn/cpp/cpp/object-lifetime-and-resource-management-modern-cpp)
- [C++ · RAII 和 智能指针 - Zhihu](https://zhuanlan.zhihu.com/p/470270741)
- [RAII和垃圾收集GC - csdn](https://blog.csdn.net/monkey_d_meng/article/details/5731935)
- [What is meant by Resource Acquisition is Initialization (RAII)? - StackOverflow](https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii)
- [什么情况下 C++ 需要垃圾处理机制？ - Zhihu](https://www.zhihu.com/question/308638046)
- [为什么 C++ 11 标准不加入 GC 功能呢？ - Zhihu](https://www.zhihu.com/question/24954016)

## 13.1 拷贝、赋值与销毁

## 13.2 拷贝控制和资源管理

## 13.3 交换操作

## 13.4 拷贝控制示例

## 13.5 动态内存管理类

## 13.6 对象移动

# 14 重载运算与类型转换

# 15 面向对象程序设计

# 16 模板与泛型编程

# 肆 高级主题

# 17 标准库特殊设施

# 18 用于大型程序的工具

# 19 特殊工具与技术

# 附 A 标准库

## A.2 算法概览

### A.2.3 二分搜索算法

`<algorithm>` 库的二分搜索算法。每个算法都可以在 beg, end, val 之后再加一个 comp 函数，否则使用元素类型的小于运算符（`<`）

`lower_bound(beg, end, val)` 返回一个迭代器，表示第一个大于等于 val 的元素，不存在则返回 end 。**即第一个可插入位置**

`upper_bound(beg, end, val)` 第一个大于 val 的元素，**即最后一个可插入位置**

`equal_range(beg, end, val)` 返回一个 `pair`，其`first`成员是`lower_bound`之返回，`second`是`upper_`。**即等于val之范围，前闭后开**

`binary_search(beg, end, val)` 返回是否包含，`bool`值

如 [LeetCode 300m](https://leetcode.com/problems/longest-increasing-subsequence/)，要求不可相等，即每次找到相等的都要在其位置替换之，故用 `lower_bound`

```cpp
#include <algorithm>
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        // last element of LIS of length i
        vector<int> d;
        for (int i = 0; i < n; i ++) {
            // use lower_bound, cuz:
            // lower_bound is the first equalled element
            // upper_bound is after the last equalled element
            int idx = lower_bound(d.begin(), d.end(), nums[i]) - d.begin();
            if (idx == d.size())
                d.push_back(nums[i]);
            else
                d[idx] = nums[i];
        }
        return d.size();
    }
};
```

而 [LeetCode 1964h](https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/) 可相等，故是替换相等区域之后的那个元素，用 `upper_bound`

```cpp
#include <algorithm>
class Solution {
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& obstacles) {
        int n = obstacles.size();
        // as in 300m,
        // d for last element of LIS of length i
        vector<int> ans(n, 1), d;
        for (int i = 0; i < n; i ++) {
            // use upper_bound instead of lower_bound
            // cuz elements in the course can equal
            int idx = upper_bound(d.begin(), d.end(), obstacles[i]) - d.begin();
            if (idx >= d.size())
                d.push_back(obstacles[i]);
            else
                d[idx] = obstacles[i];
            ans[i] = idx + 1;
        }
        return ans;
    }
};
```

# Werkzeugen

## `drogon` - Web Framework

https://github.com/drogonframework/drogon

https://github.com/drogonframework/drogon-docs

https://drogonframework.github.io/drogon-docs/#/

高性能，在 TechEmpower 基准里性能排名非常高，在其 fortune 指标里排第一 https://www.techempower.com/benchmarks/#section=data-r21&test=fortune

- [使用Wt/CppCMS/TreeFrog/Drogon/Crow等库/框架做web开发是怎样的体验？ - Zhihu](https://www.zhihu.com/question/364517370)
- [有哪些轻量级适合阅读的优秀 C++ 开源项目？ - Zhihu](https://www.zhihu.com/question/40131963/answer/2228833090)
- [C++团队用什么技术写后端？ - Zhihu](https://www.zhihu.com/question/345039462)
    - > 我知道的一般这几种选择：
    - > 1. C++写个nginx模块
    - > 2. Python web框架套个壳用Cython调用C++模块
    - > 3. Golang套个壳用cgo调用C++模块
    - > 4. C++起GRPC服务，Python/Golang/Java等随便什么语言做web端
    - > 5. FastCGI，随便找个成熟的实现
    - > 6. 找第三方的C++的网络库或者web框架
    - > 推荐2或者3，Python其实就挺好的了。别担心什么不可维护啊啥的，你要相信，以你们的水平，用什么语言都不可维护，Python至少删了重写不心疼。
- [C++可以做Web开发吗？ - Zhihu](https://www.zhihu.com/question/508173519)


## `Wt` - Web GUI library

https://github.com/emweb/wt

https://www.webtoolkit.eu/wt

## 另 `Cython` 以使 Python 可调用 C/C++

https://moonlet.gitbooks.io/cython-document-zh_cn/content/index.html

- [Cython 基本用法 - Zhihu](https://zhuanlan.zhihu.com/p/24311879)
