OperatingSystem | 操作系统

CLC: TP316

Dewey 005.43

операционная система, operating system, sistema operativo, système d'exploitation, オペレーティングシステム, ระบบปฏิบัติการ, Betriebssystem, hệ điều hành (系調行), 운영 체제（運營 體制）, ᠦᠢᠯᠡᠳᠦᠯ ᠦᠨ ᠰᠢᠰᠲ᠋ᠧᠮ (üiledül ün sist᠋ēm), үйлдлийн систем, இயக்கு தளம்

课程：MIT 6.828➡️MIT 6.S081

# 章一 操系概述

- 操系の作用
    - 位置
    - 用户视角
        - 服务
        - 用户界面：命令、GUI、系调
            - 系统调用の过程
            - 系调の类型：进程控制、文件管理、设备管理、信息维护、通信、保护
        - 不同用户不同需求
    - 系统视角：资源分配器。有效而公平。
        - 资源类别：CPU时间、内存空间、IO设备、文件存储空间
- 操系의发展过程
    - 人工操作方式
    - 单道批处理阶段：出现了监督程序，常驻内存，OSの雏形。联机批处理、脱机批处理
    - 多道批处理阶段
        - `多道程序技术`：内存中同时存放几道相互独立的程序，相互穿插运行
            - 优点：资源利用率高，系统吞吐量大
            - 特征：多道、宏观上并行、微观上串行
    - 分时系统
    - 实时操作系统
    - 批处理、分时、实时は三种基本なOS类型
- 操系の主要功能
    - 定义
    - 目标
    - 基本功能：
        - 处理机管理：进程控制、进程同步、进程通信、调度（作业调度、进程调度）
        - 存储管理：内存分配、内存保护、地址映射、内存扩充（逻）
        - 设备管理：设备分配、缓冲管理、设备处理
        - 文件管理（软件资源管理）（文件系统）：文件存储空间管理、目录管理、读写和存取控制
- 操系の基本特性
    - `并发`
        - 并行乄并发
    - `共享`
        - 方式：互斥共享方式、同时访问方式
    - `虚拟`：一个物理实体映射为若干逻辑实体
        - 体现在哪些方面：
    - `异步`
- 计算机硬件简介
    - `总线`
    - 现代计算机系统工作模式——`冯诺依曼体系结构`
    - 处理机的状态：区分OS代码和用户定义代码の执行
        - 系统中两类程序：用户程序、管理程序
        - CPU中增加一个模式位表示当前模式
            - `内核模式`か`管理模式`か处理机的特权级：此状态下处理机可以使用全部指令、全部系统资源
                - linux区分管理模式，特权少于内核
            - `用户模式`
        - 处理机状态の转换
            - 用户→内核：唯一途径は中断
            - 内核→用户：可通过设置PSW（程序状态字，在CPU中）
        - `特权指令`：能引起伤害的机器指令
            - 可执行的功能：允许和禁止中断、进程切换、操作对主存进行保护的寄存器、IO控制、定时器管理
    - 存储器：主要指内存/主存（main memory）。操作系统本身也要放到主存运行
        - の类型
            - `读写型存储器`か`随机访问存储器`（RAM）
            - `只读型存储器`（ROM）
                - 变型：PROM、EPROM、EEPROM、闪存（flash memory）（必须按块擦除）
        - 의层次结构
        - 存储访问局部性原理：提高存储系统效能关键点
            - `平均访问时间`（每级存储器发现概率乘时间加和）
        - 内外存主要区别：容量、存取速度、价格、介质（内主CMOS）、带宽、控制者
    - 时钟
        - `绝对时钟`（记录当前时间）、`间隔时钟`（通过时钟寄存器，到时触发时钟中断）
    - 中断技术：操作系统是由中断驱动的
        - 概念：CPU对系统中或外发生的异步事件的响应
        - 目的
        - 特点：随机、自动处理
        - 中断类型
            - 按中断功能分类
                - 输入输出中断
                - 外中断：¿通信中断とは？
                - 机器故障中断
                - 程序性中断
                - 访管中断
            - 按中断方式分类
                - 强迫性中断：如IO中断、外中断、机器故障中断、程序性中断
                - 自愿性中断
            - 按中断来源分类
                - 中断：处理机外部事件
                - 俘获：处理机内部事件
        - 中断系统的两大组成部分
            - 硬件中断装置
            - 软件中断处理程序
        - 中断装置の基本功能：源、态、保、址、构
        - `中断寄存器`：每源一触发器（`中断位`だ）寄存中断信号，触发器全体谓。
        - 发现中断：处理器の控制部件中有能检测中断な机构谓`中断扫描机构`，每条指令执行周期最后扫描中断寄存器
        - 中断响应：发现中断请求时中止现、引出中断处程
            - 硬件支持：指令计数器、处理机状态寄存器、系统堆栈、中断向量表
        - `中断向量表`：有的机器最低位1个字为之，每中断向量两个字。中断请求的设备接口向处理器发送设备在中向表の表目の编号
        - 中断优先级：一些机器，机器故障>程断和访断>外断>入出断
        - 中断屏蔽：可在PSW中设置中断屏蔽码屏蔽些类型，各设备接口也有中断禁止位以禁止彼
        - 中断处理一般过程：信、确、备（保PSW、PC、一些寄于系栈，切管模）、入（查表置PC）、始、环（上下文、态）、新（恢完PSW、PC）
        - 多个中断の处理：两种策略：
            - 种一：禁止中断，再次允许时再响应
            - 种二：允许高优打断低
        - 典型的中断处理
            - IO中断
                - 由IO设备控制器或通道
                - 类：正常、异常
            - 时钟中断
                - 维护软件时钟
                - 处理器时间调度
                - 控制定时任务
                - 实时处理
            - 硬件故障中断
                - 一般要做：保（保现，警）、评（高可靠环境中尽可能恢）
            - 程序性中断：指令出错、越权、越界，处理方法：
                - 法一：只能操系相关扩展功能模块完成。多为不能做的操作，如页面换入
                - 法二：程序自己完成。如算术运算错
            - 系统服务请求（自愿性中断）：处理器专用指令（访管指令）激发。现代一般不直接提供系调指令接口，而是应用层封装（API）或更高层的程序设计模板类和类库

思考题：

# 章二 进程管理

- 2.1 进程概念：描述程序在内存ﾅ运行状态，解决并发与共享带来的竞资、通信、协同
    - 相关概念
        - 进程乄程序：动态，独立运行的活动单位，竞争系统资源の基本单位。一程序可多进程。
        - 作业：批处理系统执行作业，生命周期长于进程
        - 进程是一个正在执行得程序的实例；程序的一次执行过程
    - 进程组成：内存中的进程包括代码段、数据段（含全局变）、栈、堆、PC、寄存器等
    - 进程特征：动态、并发、独立、异步
    - 进程状态：创建、运行、等待か阻塞、就绪、终止
    - 进程状态转换图：阻转就，就转运，运转俩
    - 引起转换的事件：
    - 进程控制块：进程存在的唯一标识，用户叵访，常驻内存
        - PCB主要内容：状态、PC、寄存、调度（优、队）、内存、记账、IO态
    - 进程调度：选择就转运。
        - 调度队列
            - 就绪队列
            - 等待队列，每个设备
            - 常用链表实现，头节点指首末
    - 进程队列图：展示各调度队列
    - CPU在进程间切换：由于中断或系调。要上下文切换。
    - 调度程序
        - 长期调度程序：即作业调度
        - 短期调度程序：CPU调度
        - 中期调度程序か交换（swap）：有些分时系统引入之，核心为可移除内存降低并发度
- 2.2 进程控制：pid唯一标识，父子创建成树
    - Linux 进程树
    - 父子进程的关系
        - 资源：共享所有 || 子共享父の部分 || 父子不共享
        - 执行：并发 || 父等待某或全子
        - 地址空间：相同程序数据（父の复制品也） || 装入另一个新程序
    - Linux进程创建
        - fork()建，对子进程返0，对父返子のpid，失败返负
            - 程序里以此判自己父或子
        - 子进程通过复制父の地址空间而成。通常一个进程使用exec()用新程序取代该进程地址空间
    - Win进程创建
        - 用CreateProcess()，需要将一个程序装入子进程地址空间
    - 进程终止
        - 原因：正常结束（调用exit()）、异常结束、外界干预（父可强终子）
        - 所有资源被OS释
        - 可返回状态值到父（通过wait()）
- 2.3 进程间通信（interprocess communication, IPC）：并发进程欲协作则要之以交换数据
    - 共享内存系统：胶粒协作进程皆可读写な共享内存区，驻留在创建它的进程的地址空间内，要向OS申请取消访他进程限制，的访问同步由协作进程负责
    - 消息传递系统：可用于不同机器
        - 直接通信方式：系统调用で直发
        - 间接通讯方式：邮箱で发收，箱可以为进程或OS所有
    - 其他通信方式
        - 管道（pipe）
            - 普通管道/匿名管道：单向，只用于父子
            - 命名管道：可双向，win的还可用于异机
        - 客服通信（Client/Server）
            - Socket通信：低级，无结构字节流を交换，由进程来解释
            - RPC（Remote Procedure Call）：交换的消息具有明确结构
                - RPC服务监听端口，消息包含函数标识及参数
- 2.4 线程：进程切换代价太高，故以线程为CPU调度基本单位。减少并发执行时空开销，并发性更好
    - 线程：又称轻量型进程，是进程内个相对独立的可执行单元。有线程控制块TCB，含线程ID、PC、寄、栈。与同进他线共享代码段、数据段、其他OS资源（打开的文件等）
    - 单线と多线程：同code, data, files;独reg, stack, PC
    - 服务器にの多线程：监听，新线程相应请求
    - 多线程の优点
        - 响应度高
        - 资源共享（通信简单）
        - 效率高（创建和调度）
        - 并发度高（进程可多核）
    - 多核并行
    - 线程池（thread pool）：进程开始时创建些线程，待用
        - 优点：比现建快；可限制可用线程数
        - 数量由CPU数量、内存大小、并发客户请求期望值，可动态调
    - VS2012 C++ 多线程编程
    - Java 多线程编程
- 2.5 处理机调度：实质是梳理机资源的分配。进程はIO密集型乄计算密集型，IO密应尽快得机会
    - 何时调度
        - 非抢占式调度（nonpreemptive）：主动放弃CPU
            - 当运转阻（IO或wait()）
            - 等终止
        - 抢占式调度（preemptive）：现代广泛
            - 当运转就（时钟中断）
            - 当阻转就（IO完或signal()唤。是否新就绪马上运行，取决于调度算法）
    - 调度准则
        - CPU使用率
        - 吞吐量：单位时间完成数
        - `周转时间`：提交到完成
        - `等待时间`：就绪队等待
        - `响应时间`：请求到响应
    - 调度算法目标
        - 共同目标：公平、平衡、策略强制执行
        - 批处理系统目标——作业调度
            - `平均周转时间`短
                - `带权周转时间`： $周/运行时间$
                    - *(有点像「比体积」一类的量，每个运行时间对应的周转时间，也就是其工作「水」的程度吧)*
                - 系统吞吐量高
                - CPU利用率
                - 指标有一定冲突，如SJF，吞吐高，长作业周转差
        - 分时（交互式）系统目标
            - 响应时间快
            - 均衡性：满足期望，不同操作不同期望
        - 实时系统目标
            - 保证截止时间
            - 可预测性
    - 算法
        - `先到先服务`（FCFS, First-Come, First-Served）
            - 非抢占
        - `最短作业优先`（SJF, Shortest-Job-First）：取决于下次CPU执行时间
            - 最小平均等待时间，吞吐量高
            - 困难在于如何知道下次执行时间（一般用于作业调度，用户提交时制定）
            - 抢占式的也称最短剩余时间优先调度
        - `轮转调度算法`（RR, Round Robin）：基于时间片
            - 简单公平，常于分时
            - 就绪FIFO，类似FCFS而加抢占式切换
            - 时间片一般10~100ms
            - 平均等待时间较长（长于SJF短于FCFS）但响应快
            - 时间片一般为80%进程一次服务时间
            - *自己时间片没用完那还是立刻让下一个进程来，不是死的时间窗*
        - `优级`
            - RR假设优先级同，FCFS等待时间为优先级，SJF下次CPU执行时间的倒数优先级
            - 优先级确定
                - 静态优先级：重要性、费用、政治因素等人为
                - 动态优先级：一些测量数据，如内存专用、打开文件数、平均IO执行时间与平均CPU执行时间之比
            - （本课程用小整数表示高优）
            - 可以抢或非抢
            - 主要问题：低优先级「饥饿」
                - 解决——老化（aging）：定期增就绪队列排队进程の优先级
        - `多级队列`：容易分组时，几个单独队列，按属性如内存大小、优先级、类型。各队调度算法可异。
            - 队列之间通常固定优先级抢占调度，也可以每个队列一定比例CPU时间。
            - 实时>系统>交互>批
        - ``多级反馈队列`
            - 普通多级队列开销小但不灵活。多馈允许进程在队列间迁移，占用CPU多的移低，低中等候多时移高。
                - 低优なの时片长
            - 最通用、最复杂
            - 特点：照顾了交互进程（优先级高）也照顾了计算密集型（时间片长）

思考题：

- 如果进程刚开始需执行一段长时间，后又需要交互？

些题

- 处理机调度（考虑可抢占/不可抢占、单道/多道、优先级、内存限制、I/O 处理等）
    - 进程调度算法
        - FCFS
        - SJF
        - 高响应比优先
        - 时间片轮转
        - 优先级调度
        - 多级队列
        - 多级反馈队列
    - 课件喜欢画单个CPU的条条图

# 章三 进程同步

- 3.1 临界区问题
    - 进程间相互制约关系：资源共享导致
        - 间接制约关系か互斥
        - 直接制约关系か同步
    - 经典问题——生消。有界缓冲区。两个都修改counter的值，但机器语言分三条指令，可打断使不同结果。
    - 临界区
        - 邻接资源：一次仅允许一个进程使用
        - 临界区：进程中访问临界资源的代码段
        - 为保证互斥访问，出入临界区都要检查
        - 临界区问题解答条件
            - 互斥（mutual exclusion）
            - 进入（progress）：只有不处于剩余区者能决定权限
            - 有限等待（bounded waiting）：从请求到允许，其他进程进入次数有限
- 3.2 进程同步方法
    - 两进程同步解决方法
        - Dekker算法：俩flag一turn，flg1，对方flg1且turn就flg0并等到自己turn，flg1；执行完turn给对方，flg0
        - Peterson算法：更简，flg1，先给彼turn，彼turn且flg1则等；完了flg0
            - 只双进程
            - 不用原子，纯软件
            - 要注意限制CPU对内存访问顺序改变（编译器优化）
            - 基于软件的，在现在计算机体构不能保证正确工作
    - 多进程同步解决方法
        - 屏蔽中断：临界区前屏断，离遂开，通常非抢占式内核采用
            - 多处理器不可行（要把屏蔽消息给所有CPU，低效）
            - 让用户进程屏蔽中断不太妥
        - 硬件指令：许多计算机提供原子操作
            - 原子操作
                - `test_and_set` 以检测修改内容（置1并返原值）
                    - 单参数，共享变量lock也。出临界区的设lock0，想进一直tns它直到看到0
                - `compare_and_swap`：交换（返val原值，若val==expe则置为newval）
                    - 也是出区置0，进区一直cns(&lock, 0, 1)直到为0
                - 它俩满足互斥，不满足无限等待
            - 改进的算法
                - 出区从自己往后看有waiting的就解围，否则lock0让自由争
        - 互斥锁变量：硬件实现原子的互斥锁，入acquire出release（硬件方案复杂，且不能程序员直接用，故构建软件工具）
        - 前述算法的问题——忙等待（busy waiting）
            - 这样的互斥锁谓`自旋锁`（spinlock）
            - 临界区执行时间应尽量短
        - 信号量（semaphore）：解决同步互斥问题之更通用，Dijkstra，信号量Sは整型变量，初始化外只有原子操作wait()signal()来访问（通过屏蔽中断或硬件指令实现）
            - 物理意义：正数は资源数，负数绝对值は等待使用的进程树
            - 信号量の类型
                - 二进制信号量：只能01，似互斥锁
                - 计数信号量：可以所有整数，控制多实例的资源（初值是可用资源数），需要使用wait，用完signal，s==0时皆在用
            - の定义と实现
                - 创建时说明意义和初值（决不能负）
                - 为解决忙等，加个进程等待队列
                - 两个成员，val、list
                - wait()かP()：申请资源
                    - S.val--
                    - ≥0则有资源，可执行
                    - ＜0无资源，阻塞（block()），插list尾，转CPU调度
                    - ＜0时绝对值表待用者数，即排队PCB数
                - signal()かV()：释放个资
                    - S.val++
                    - S.val＞0则继续
                    - ≤0则唤醒个（阻塞改就绪, wakeup()）
            - で互斥
            - で同步
            - の操作の讨论
                - PV必成对，互斥同进程，同步异进程
                - 两个P连一起要注意顺序，不当则死锁
                - 两个V顺序不要紧
                - 同步P在互斥P前
                - 优点：表达能力强（以可解任）
                - 缺点：不够安全，使用不当死锁；复杂问题实现复杂
        - 管程（monitors）：信号量无意的编程错误会致死锁又难检；管程则统一处理临界资源の访问
            - とは：一种抽象与封装，定义一组变量和操作变量的函数实现（声明、、初始化操作）
            - の特性：临界资仅可用之，之确保每次仅一个进程在管程内处于活动态；程序员不用显式写同步只需调用；编译器知道其特殊；Java支持，method前加synchronized；C/C++不支持
            - 条件变量：即阻塞的原因
                - 每个条件变量一个链表，记录阻塞者
                - 只有PV操作
                - 与信号量的PV区别：后者会改信号量状态
            - P调用管程执行x.signal()唤醒Q，谁先执行
                - 法一：唤醒并等待，P等
                - 法二：唤醒并继续，Q等
                - 一般做法：signal()为最后个操作，执行完离开管
- 3.3 典型的进程同步问题
    - 生消：有界缓存
        - 信号量で
            - sema mute, full, empty
        - 管程で
        - 管程のJava实现
    - 哲餐：5人5根筷拿左右筷，吃完放。需要不死锁不饥饿
        - 可采取的措施
            - 最多允许四个哲学家
            - 在临界区拿筷子，只有两边都可用才行
            - 非对称，奇数先拿左，偶右
        - 管程で
            - 两只筷子才拿的方案
            - 三状态thinking, hungry, eating，两个邻居都不进餐才eating，五个条件变量用来延迟自己（跟调eating一起唤醒）
        - 可能饿死。
    - 读写：允许多个读者读，而写者排他访问。与优先级有关的三种模式
        - 模式一：读者优先：有写者等着也能读，没有读写者才能写。写者会饥饿。
            - 计数器read_count（并mtx之）
            - sema rw_mtx=1, mtx=1; int r_cnt=0;
        - 模式二：公平竞争：写等则读等。写者会饥饿
            - sema rw_mtx=1, r_mtx=1, mtx=1; int r_cnt=0;
                - 读写一起等r_mtx
        - 模式三：写者优先：都排队时写者优先。作为思考题。

些题

- 进程的同步与互斥（PV操作）
    - 生消
        - 切记先生产再临界，先临界再消费
        - 有限缓冲区：缓冲区也得mtx，然后生的full启消，消empty启生
        - 父女母子一盘：父母抢盘子，但子女只要等是自己的就行
        - 理发师1理椅n等椅：顾客有cnt，满了走不满等且每人放full，理发师被唤醒先cnt--（挪到理发椅）再做再放emp。相当于生产者（顾客）能判满，先生产再喊消费
        - 叫号式：客取号就等，主看既务号，小就++服务对应人，不然不动
    - 读写
        - 读者都要计数，保证最后第一个读者申请file，最后一个放回去，因为它们能一起读所以用这个维持起始（まあ、一定程度上优先就代表计数记完再还，别人只能等）
        - 写者即之间互斥，所以write前申后放
        - 读优：读者申请的file把写者封死，但读者数量还能增
        - 公平：写者来了用canR封后面的读者（但要等现在的完），写完再释放
        - 写优：写者也计数，cntW其实与R不同，表示排队，但第一个把canR封了，最后一个才解开
        - 独木桥：一方有人了能连续过而另一方一直等，相当于是独木桥是个file，两边都是优先的读者。
    - 哲餐
        - 筷子是5个信号量的数组没差
        - 法一：只能4个人动，act=4，每次进去就P(act)完全出来再V(act)
        - 法二：一个mtx，让人拿着它等俩筷子，等完再Vmtx出去，不会有同时等着的
        - 法三：奇偶左右

自旋锁（spinlock）、互斥锁（mutex）、读写锁、悲观锁、乐观锁：。。。

# 章四 死锁

- 4.1 `死锁`概述
    - 资源
        - 可抢占性资源：如内存，可换到硬盘
        - 不可抢占性资源：只能自行释放
        - 资源の使用顺序：请求（阻塞直至可用）、使用、释放
    - 死锁の定义：一组进程每个都在等待该组其他进程才能引发的事件。通常与竞争不可抢占资源有关。
    - 死锁の类型
        - 资源死锁：竞争
        - 通信死锁：协同。可用超时重发解决
    - 产生死锁の必条
        - 互斥：（至少一个资源是）
        - 占有并等待
        - 不可抢占
        - 循环等待
    - 处理策略
        - 预防死锁：破坏必要条件
        - 避免死锁：分配时防止进入不安全状态
        - 检测死锁并恢复：允许进入死锁。资源利用率、吞吐量好
        - 忽略该问题：人工重启。win、linux等大多系统采用之。代价小。开发人员自己程序解决。
- 4.2 死锁预防：破坏四个必要条件之一
    - 破坏互斥条件
        - 资源不独占，如只读文件
        - 对于非共享资源，如打印机，可以用假脱机打印机（spooling printer）技术
            - 唯一真正请求使用物理打印机的是打印机守护进程。它不会请求别的资源所以不死锁
            - 用户进程只要数据输出到假脱机磁盘空间
    - 破坏占有并等待条件：保证申请一个资源时不能占有其他
        - 协议一：执行前必须一次性申请全部。利用率低，易饥饿
        - 协议二：申请其他前释放已分配的所有
    - 破坏不可抢占条件
        - 申请不能立即分配的资源，则已占有的都能被抢占
        - 通常应用于状态可保存恢复的资源如内存
    - 破坏循环等待条件
        - 所有资源完全排序，要求按序号递增申请
        - 想申低先释放高
        - 优：资利用率、吞吐较高
        - 缺点：实际需要的顺序不一定与资源编号一致，仍会浪费
- 4.3 死锁避免：分配状态决定于可用、已分配、最大需求。允许动态申请，分配前先计算安全性，分配后仍处于安全状态。动态监测分配状态确保循环等待条件不可能成立
    - 安全状态：能按某顺序分配资源并避免思索，或说存在进程结束的安全序列
        - 举例
    - **银行家算法** van Dijkstra。进程进入系统要说明可能需要的资源最大数量每种，申请资源时系统必须确定是否仍处于安全
        - の数据结构
            - 可利用资源向量 Available
            - 最大需求矩阵 Max：行进程列资源
            - 分配矩阵Allocation：行已分配列资源
            - 需求矩阵Need：还需要的
        - 安全性算法
            - 定义数据结构：Work[m]各资源潜在可用量，Finish[n]各进程能否结束，m资源n进程
            - 每次找没结束并且资源小于可用的，有就给它资源并置结束，再找，全完了安全，有分不了的不安全
        - 资源请求算法：大于需求报错，大于可用等待，分配就分配了，然后安全性检查，不安全就恢复让等待
- 4.4 死锁检测与修复
    - 资源分配图：进程圆圈，资源方框（小圆资源数），箭头表示去申请或分配给（申请边留着代表阻塞）
        - 无环一定无死锁，有环可能有（有环且资源都单个实例则一定死锁）
        - 化简：不阻塞进程所有请求和分配边去掉，形成孤立点，回收资源，重复到每个都孤立就可完全简化
            - 死锁定理
                - 可完全简化则不会产死锁
                - 不可完全简化（即还有边）则会死锁
    - 死锁检测算法
    - 应用检测算法
        - 调用时机
            - 每次请求分配不立即允许时（开销很大）
            - 定时监测（如每小时）
            - CPU使用频率低于40%时
        - 取决于因素
            - 死锁可能发生频率
            - 死锁发生有多少进程会影响受
    - 死锁恢复
        - 基本方法
            - 法一：简单终止一个或多个进程
            - 从一个或多个死锁进程抢占资源
        - 终止进程
            - 终止所有死锁进程
            - 一次终止一个直到消除死锁循环
                - 开销大，每次调用检测算法
                - 终止的选择是代价小的
            - 终止并不容易，会使文件在不正确状态
        - 资源抢占
            - 需要处理的问题
                - 选择牺牲进程
                - 回滚：使回滚到安全状态并重启（最简单的是终止而重新执行）
                - 饥饿：总是从一个进程抢占就

些题

- 银行家算法
    - 将请求向量拿来更新Allocation，然后安全性
    - 安全性就是Max-Allo=Need，谁的Need能满足就结束了把Allo收回来，直到都满足。每次被同时能满足的一块儿解决。
- 资源分配图
    - 申请而分配给了的资源画的是分配边（资源→进程）
    - 化简就是把申请能满足的满足了

# 章五 内存管理

- 5.1 概述
    - 存储管理的主要功能应包括？
    - 内存保护：`基址寄存器`、`界限寄存器`
    - `地址绑定`：每次都是从一个地址空间到另な映
        - 编译时绑定、加载时绑定、执行时绑定
    - 逻辑地址与物理地址
        - `逻辑地址`か`虚拟地址`：CPU所生
        - `物理地址`：内存单元所见（加载到内存地址寄存器）
    - `内存管理单元`（`MMU`）：逻辑地址を物理地址に。程序不见物址，引用时与基址寄存器（`重定位寄存器`）相加方可定位。
    - `动态加载`：所有程序以可重定位加载格式存于磁盘，主程序先加载到内存，其他模块在需要时再用`可重定位链接程序`加载，并更新程序的地址表。
    - `交换`（swap）：内存空间不够时进程从内存交换到外存。耗时。
        - 可以选择换出后继续让缓冲区和IO交换数据（让设备控制器来控制），但缓冲区和进程内存以及进程自己的处理一定不能用了
- 5.2 连续内存分配：早期方案，已弃
    - 两个分区（partition）——`操作系统区`、`用户进程区`，每进程は连续な内存区域を
    - 按分区划分方式分类：
        - 固定分区：内存划为多个固定分区，可同大或不，每は一进程。
            - 在作业大小と频率已知时合适
        - 可变分区：建进程时按需分区。OS管 `已分配分区表`と`空闲分区表`（空闲区链表）
            - 事先设定阈值，某空闲区减申请小于阈值则整个分给。以免外部碎片を。
            - 空闲区搜索算法と碎片问题
                - `首次适应法`（first-fit）：第一个足够大空闲区。可从链表头开始找也可以从上次结束の下位（循环首次适应法）
                - `最佳适应法`（best-fit）：满足な最小な空闲区。
                - `最差适应法`（worst-fit）：最大な空闲区
                - 三种策略比较：首、佳的空间利用和执行时间更好，首比佳快
                - 碎片问题：外部碎片、内部碎片（分配到多余实际需求）
                - 解决碎片：紧缩（定期压缩）、阈值（减外增内）、允址不连（分段か页管理）
- 5.3 分段（segmentation）：支持按段的用户视图的内存管理方案。每个段连续内存，逻辑地址空间为一组段
    - 段：按程序自身逻辑关系划为几段
        - C/C++ 编译的程序：栈区（stack）、堆区（heap）、全局区か静态区（static）、文字常量区、程序代码区
    - `段表`：实现逻址转物址
        - 逻辑地址は <`段号`, `段内偏移`>
        - `段表寄存器`存放段表基址と段表长度，段表には一组段长と段基址。段号太大（＞段表长度）か段内偏移太大（＞段长）なら`越界中断`；否则，段表中凭段号找段基址，加偏量得。
- 5.4 分页（paging）内存管理方案
    - 固定大小な帧（frame，物理内存）、页（page，程序の逻辑地址空间）という块
        - 帧、页同大小，皆 $2^k$ 字节
        - 免外部碎片
    - 地址转换：CPU 产两部分（页号、页偏移）
    - 页表：逻址到物址
    - 页大小：太大浪费（每进程平均半页内碎）太小页表过长，常4~8KB
    - 页表在内存，寄存器为`页表基址寄存器`、`页表长度寄存器`在PCB中，切换只改它们
    - `快表`
        - CPU的cache中有`转换表缓冲区`（`TLB`，translation look-aside buffer），放在TLB中的部分页表谓快表
        - TLB中查找时，同时与所有条目比较，没找到再找内存并放入TLB
        - 有的在TLB条目中有ASID标识进程，则切换不需改TLB
    - 用页号在TLB找，找不到在页表找，得到页基址，加偏移量得物址
    - 共享页：共享内存通信的一种实现
    - 分级页表：页表再分页，一个顶级页表，分到最后的页面大小等于内存帧
        - 栗子：32位系统，页4KB，则逻辑地址空间一共有 $2^{32}B/4KB = 2^{20} = 1M$ 页，取页表项大小4B，需要占4MB的页表装下所有表项，装个屁。
            - 改用多级，x级，使每个页表有一页大。每页表项 $4KB/4B = 2^{10}$ ，则要x次方不小于总页数，即 $(2^{10})^x ≥ 2^{20}$ ，解得 $x ≥ 2$ ，需要两级分页。
            - 64位的话， $2^{64}B/4KB = 2^{52}$ 页， $(2^{10})^x ≥ 2^{52}$ 得到 $x≥6$ ，我觉得是6级页表，课件说7级？？？
    - 页内地址因为是后几位，同时页长 $2^k$ ，因此最后几位是页内偏移不会溢出。但页号会越界吗，要检查吗？？？
- 段页式：程序分段，每段分页
    - 逻址は段号、页号、页内地址。
    - 每个分段一个页表。因此进程中段表只能一个，页表可能多个也

些题

- 地址映射：
    - 页，页表里是页号
        - 给页长、页表，画出地址变换图以由逻址定物址：（转成二进制比较清楚）分原为表偏，表号共表首寻帧号，帧号（乘以偏移量范围）加偏移得物址
    - 段，段表里是段始
        - 段始直接加偏移量得物

# 章六 虚拟内存管理

- 6.1 虚拟内存
    - 概述
        - 不需要整个程序都放入内存（少用到的功能、超出实际的分配）
        - 分段能都执行只有部分处于内存的程序
        - 好处：不受物理内存限制简化编程；运行更多程序；程序启动更快
        - 逻辑内存与物理内存分开
        - 虚拟地址空间就是在内存存放的逻辑视图
        - 可大于物理内存
    - 虚拟地址空间：内存需求动态变化，堆栈之间是虚拟地址的一部分，生长时才需要实际物理帧
    - 好处：共享对象映射到虚拟地址空间则系统库可多进程共享；允许进程通过共享内存页通信
- 6.2 请求调页（demand paging）
    - 概述
        - 页面只有请求时加载到内存。采用惰性交换方法。也称按需调页。
        - 乄交换：交换是整个进程
        - 硬件支持，以区分页在硬还是内
            - 页表增加一位指示，valid-invalid bit
            - 访问invalid页面，出现缺页错误，产生缺页中断
                - 检查进程的内部表（PCB中，四肢引用无效则终止，有效但页不在内存则准备调入）
                - 找空闲帧，调度一个磁盘操作读到刚分配的帧，完成修改页表，中断返回
    - 交换空间の使用
        - 交换空间比文件系统IO快（分配块更大，管理少）
        - 方案一：进程加载时整个文件映像复制到交换空间
        - 方案二：第一次调入时文件从文件系统请求调页，后续的调入调出从交换空间
        - 方案三：二进制文件，直接从文系调入，释放内存帧时直接丢弃不用调出
            - 需要写入交换空间的情形：文件无关的页面——匿名内存；页面在内存修改过但没有写回文件系统
        - Linux有一个交换分区（一般为内存1~2倍）
        - 移动操作系统一般不支持交空
- 6.3 页面置换（page replacement）
    - 概述
        - は请求调页的基础で，完成了逻辑内存和物丶の分离
        - 当发生缺页错误而没有空闲帧时需要
            - 页面置换算法で牺牲帧を选
            - 修改过则写到交换空间
                - 页表条目增加修改位
            - 所需页面调入该帧
            - 修改页表等相关表
    - **页面置换算法**
        - `FIFO`：置换最早进入内存な
            - 实现方法：建立队列；置换队首；新调入加到队尾
            - `缺页错误数`
            - `Belady 异常`：（4帧缺页错误多于3帧）
        - `OPT` 最优页面置换算法：置换最长时间不会使用的
            - 最低的缺页错误数
            - 难实现，因为需要页面的未来知识
            - 可作为比较其他算法优劣的标准
        - `LRU` `最近最少使用算法`：用最近的过去作为不远的将来的近似（类似SJFでCPU调度）
            - 概述
                - 最常使用
                - 精确实现很困难，要有复杂硬件支持
            - の实现方式
                - 计数器的实现
                    - 增加使用时间域（计数器），每次页面引用时CPU时钟寄存器内容复制焉
                    - 置换最小时间者（搜整个页表）
                - 栈の实现
                    - 引用时挪到栈顶
                    - 最近最少使用在栈底
                    - 双向链表で，不用搜索
            - LRU近似算法
                - 引用位：页表条目增加引用位，引用时置1
                - `时钟算法`（又叫最近不用`NRU`（not recently used））：第二次机会算法
                    - FIFO基础增加引用位
                    - FIFO选择时，引用0则用，窦泽置0并下找；类似时钟走法也
                - `改进型时钟算法`：结合引用位と修改位
                    - (0,0)：未用未改，最佳牺牲
                    - (0,1)：未用已改，换前写
                    - (1,0)：已用未改，可能快再用
                    - (1,1)：已用已改，尽量不换
                    - 特点：可能多次扫描才找到置换页；为已修改的页面更高的级别，可降低IO量
            - 页面置换性能影响因素：置换算法の缺页率，页面写回磁盘频率，页面调入内存频率
    - 页面缓冲算法
        - 系统保留空闲帧缓冲池，缺页错误时置换算法选牺牲帧，牺牲帧写到磁盘前页面调到缓冲池的空闲帧（尽快启动），调页设备空闲时牺牲帧写出并添加到空闲帧池
        - 进一步改进
            - 保持缓冲池中帧内容完好，记录对应页面；缺页错误时，检查是否在缓冲池，不在才调 *（但已经写进磁盘了对吧，就是没费劲清空它呗）*
            - 可以降低错误选择牺牲页引起的开销
        - 可用来改进任何页置算法
    - 全部置换と局部置换
        - 全局置换
            - 允许从所有帧集合选择置换帧，可以从其他进程特别是低优先级
            - 吞吐量高，常用
        - 局部置换
            - 只能从自己已分配的帧
            - 每进程帧数固定，性能稳定；内存利用率低
    - 系统`抖动`（thrashing）か`颠簸`
        - 进程没有所需足够帧数，所有页面都在使用，刚置换掉页面很快再次调入，页面调度频繁
        - 严重性能问题（CPU利用率とか）
        - 原因：页面置换算法不合理；分配物理帧太少（如并发度过高）
    - 缺页错误率：控它是防止抖动更直接な方法
        - 错误率太高：要给进程更多帧
        - 错误率很低：有太多真，收回一些

些题

- 页面置换算法
    - FIFO（装入）、LRU（上次饮用）、简单CLOCK（读标志位）、改进CLOCK（读标志位、修改标志位）

# 章七 磁盘管理

- 7.1 磁盘概述
    - 概述
        - 大容量存储系统：磁盘HDD、非易失存储器NVM（SSD、U盘）、磁带、CD、DVD等
        - 磁盘：盘体大小、转速
        - 磁盘地址：柱面号·盘面号·扇区号
    - 移动磁头的磁盘装置：读写时磁头与盘面间隔几微米
    - 磁盘の性能
        - 传输速率
            - 理论速率
                - 接口速率/外部速率：硬盘缓存到内存
            - 内部速率/持续数据传输率：磁介质读取数据到磁盘缓存
            - 实际速率/有效传输速率
        - 随机访问时间（定位时间）
            - 寻道时间（seek time）：移动磁头到包含目标扇区所在柱面
            - 旋转延迟（rotational latency）：旋转目标扇区到磁头下
        - 磁盘IO时间
            - 寻道时间+旋转延迟+控制器开销+数据传输时间
        - 时间主要花在磁头定位；SSD硬盘没有移动部件所以很快
    - 结构
        - 可看成有逻辑块组成的一维数组；逻辑块是最小的传输单位；
        - 逻辑块数组映射到磁盘扇区
            - 扇区0是最外柱面一磁道一扇区
            - 映射顺序磁道内扇区、柱面内磁道、柱面
            - 坏扇区映射用磁盘其他空闲扇区
        - 磁盘旋转是恒定角速度，为保持数据速率不变内圈磁道比特密度高
    - 格式化
        - 低级格式化/物理格式化：分成磁盘控制器能读写的扇区；每个扇区除了数据区还有头部尾部控制信息；读写时磁盘控制器数据校验
        - 分区：柱面组成多个分区
        - 逻辑格式化：创建文件系统，初始数据结构存储在分区，包括空闲和已分配空间和空根目录
        - 磁盘的读写：磁盘IO以扇区为单位，文件系统以簇
            - 一个簇多个扇区，各文件系统规定不同
            - 提高读写效率：确保IO有较多的顺序访问
- 7.2 **磁盘调度**
    - 概述：管理磁盘IO请求的处理次序，可以改善访问时间和磁盘带宽
        - 访问时间中旋转延迟不可控，改善就减平均寻道时间
        - 磁盘带宽是传输字节的总数处以第一个服务请求到最后请求完成的总时间
        - 要IO时，发请求信息：输入/输出，磁盘地址。内存地址。传输扇区数
        - 以前是OS负责请求队列管理个磁头调度，现在是磁盘内な控制器
            - OS仅提供LBAs(Logic Block Addressing)，处理请求的排序
    - `先来先服务` `FCFS`
        - 移动了nnn柱面
    - `最短寻道时间优先` `SSTF`：即要求访问磁道与磁头最近，导致部分请求饥饿
    - `SCAN` 扫描算法：磁头在磁盘两端来回扫描。亦电梯调度
    - `C-SCAN` （Circular SCAN） 循环扫描：柱面看成循环队列那样，返回时不处理请求，避免两端请求等待时间过长
    - LOOKとC-LOOK分别改进两个SCAN，只移动到一个方向的最远请求
- 7.3 磁盘连接：方式は：
    - 主机连接
        - 磁盘驱动器通过IO总线与计算机项链，本地IO端口访
            - ATA, SATA, eSATA, SCSI, SAS, USB, FC
        - SSD固态硬盘因为速度快，通过NVMe(NVMexpress)直接连到PCI总线
    - 网络连接
        - 网络连接存储（NAS）设备是一种专用存储系统
        - 主机通过RPC访，RPC在TCP或UDP
    - 云存储
        - 与NAS类似，以网络
            - NAS：LANで。延迟小、通信错误少
            - 云存储：通过因特网或WAN访问数据中心。延迟大、错误多、NAS协议不合适
        - 不同
            - NAS作为另一个文件系统（NGS, CIFS）的方式提供
            - 云存储通过API
                - Dropbox, OneDrive, Apple iCloud, 百度网盘
    - SAN
        - NAS存储IO小号数据网络带宽，增加延迟
        - 存储区域网络（SAN）专用网络，使用存储协议而非网络协议
        - 灵活性好
            - 多主机多存储阵列可以同一个
            - 动态分配到主机可以
            - 服务器集群可以共享存储
        - 通常用语大容量存储。一般采用FC连接之
- 7.4 RAID 结构。磁盘冗余阵列（Redundant Array of Inexpensive Dick）
    - 性能和可靠性问题を处理
    - 连接
        - 直接连接到主机总线
        - 朱能主机控制器控制多个直接连接的磁盘
        - 存储阵列或RAID阵列
    - 冗余提高可靠性
    - 并行提高性能
        - 镜像
        - 分散
    - RAID级别
        - RAID0：数据分条，无冗余
        - RAID1：磁盘镜像
        - RAID10 好于 RAID01
            - 10是镜像完了外面是个0统摄分条
            - 同时坏的可能性很小（因为组合时也是先1组合起来再0）
        - RAID5 最常见，块交错分布奇偶校验，数据和校验分散，避免RAID4对校验盘的过度使用
        - RAID6用两个地理教研算法得两个校验码，允许两个磁盘故障
        - RAID50=5+0, 60=6+0, 100=1+0+0

些题

- 磁盘调度
    - FIFO, SSTF, SCAN, C-SCAN, LOOK, C-SCAN
    - 注意C-也算在磁道数里
    - SCAN时初终值别多想，就用磁道的上下界做加减

# 章八 IO 系统

- 8.1 IO系统概述
    - IO硬件
        - 类型很多：存储设备、通信设备、人机交互设备
        - 端口port：设备连接点
        - 总线bus：一组线路和通信协议，一组设备用
        - 控制器controller：可以操作端口、总线、设备
            - 有些很简单集成在主板如串口の
            - 有些很复杂需要单独的板卡如SCSI控制器、FC、显卡
            - 有些设备有内设控制器如磁盘
    - 典型的PC总线结构
    - 常用IO设备与接口速率
    - IO设备の特性
    - IO系统の基本功能
        - 隐藏物理设备细节
        - 与设备的无关性
        - 提高CPU、IO设备利用率
        - IO设备を控制：轮询、中断、DMA、通道
        - 确保对设备正确共享：独占、共享
        - 错误处理
    - IO系统の层次结构：用户层软件、设备独立性软件、设备驱动程序、中断处理程序、硬件
    - 各种模块之间な层次视图：？？？控制器在中断处理程序和硬件间
    - 设备驱动程序の功能
        - 接收设备无关软件发来的命令和参数，转为设备相关的底层操作序列
        - 发出IO命令
        - 及时向用设备控制器发来的中断请求，根据中断类型调用中断处理程序
    - CPU如何与控制器交互
        - 控制器有多个reg，用于数据和控制信号
        - IO指令方式：特殊IO指令，触发总线
        - 内存映射IO方式：设备控制寄存器映射到内存，简单高效，现代倾向此
- 8.2 设备控制
    - 概述：设备与控制器间的接口
    - 设备控制器の组成
    - 基本功能
        - 接受和识别命令、数据交换、标识和报告设备的状态、地址识别、数据缓冲区、差错控制
    - 按照IO控制器智能化程度高低分控制方式四类
        - 轮询方式：反复测试完成位。浪费大量CPU时间
        - 中断方式：中断处理程序中吧数据缓冲寄存器中取到内存，以后调度到进程再从内存取
            - IO中断方式分析
                - 优点：CPU利用率
                - 缺点：输入输出每个字节中断，次数多
                - 减少中断对CPU造成负担，用后二方式
        - DMA方式（Direct Memory Access）：数据传输基本单位是数据块，设备直接到内存，数据块开始结束才CPU干预
            - DMA控制器
            - DMA方式の工作流程图
            - DMA方式工作过程：给它内存始址、字节数
            - DMA方式与中断な主要区别
                - 中断是数据缓冲寄存器满，DMA是数据块全部结束
                - 数据传送不用CPU处理
        - IO通道方式
            - 一次读多个数据块，分别不同内存区域
            - 是专门处理IO操作的处理机
            - 有自己指令系统，通道程序，只能执行通道程序
- 8.3 缓冲技术
    - 是不同速度设备传输信息常用的平滑手段
    - 类别
        - 硬件缓冲器：的存储装置，容量小速度快
        - 软件缓冲：临时存放数据的存储区域
    - を为何引入
        - 数据流生消速度差异
        - 协调传输数据大小不一致的设备
        - 应用程序的拷贝语义（保证写入就是系调时的版本）
    - 常用な缓冲技术
        - 单缓冲区：请求时分配个
            - 工作示意图
        - 双缓冲区：进一步提高并行，速度基本匹配时好
            - 工作示意图
        - 环形缓冲区：循环队列
        - 缓冲池：系统资源，OS统一管理，可供多个进程共享，可组队

# 章九 文件系统

- 9.1 文件概述
    - 概述
        - 文件：OS提供信息存储的统一逻辑视图。逻辑外存的最小分配单元
        - 文件の类别
            - 普通文件
            - 目录文件
            - 特别稳健：有的系统，设备作为文件统一管理，称设备为特别文件
    - 属性：放在目录项中，包括：文件名、标识符、类型、存储位置、大小、保护、时间
    - 操作：抽象数据类型だ
    - 类型
    - 逻辑结构
        - 流式文件：基本信息は字节，无结构
        - 记录式文件：有结构。一组记录集合。现代OS取消之。
    - 访问方法
        - 顺序访问：主要于磁带
        - 直接访问：相对访问/随机访问，主要用于磁盘等随机访问设备
        - 索引访问：少
    - 保护
        - 文件/目录にの基本操作类型：read,write,execute, append, delete, list
        - 每文件、目录设置基于用户身份的访问控制列表ACL太复杂
        - 精简访问列表，每文件三种用户类型：owber, group, other
        - 访问模式 read, write, execute
        - 改权限 chmod 761 doc
    - 共享：允许多用户或进程共享一份。节省存储空间、通过文件交换信息也
        - 链接技术で：不同名字一个文件
            - 硬链接：相同对象
            - 符号链接（symbolic link）か软链接：不是单独文件，数据块指向源文件的符号？？？
            - 硬乄符
            - 快捷方式：普通的文件而非符号，指向任何合法位置，只有一些程序能读它
- 9.2 目录结构
    - 概述
        - 磁盘和多个分区，每个分区可安装一个文件系统（或用于交换空间），包含文件系统的分区谓卷（volume）
        - 文系管理百万文件，目录で组织
    - 目录操作：搜索、创建 、删除、遍历目录、重命名、遍历文件系统
    - 单级目录结构：所有文件同一目录，异名，检索久
    - 两级目录结构：主文件目录MFD，每个用户单独文件目录UFD
    - 树形目录结构：最常用，一个根目录，其他各级目录是目录文件，文件唯一路径名
    - 无环图目录：具有共享（多用户共享）的目录か文件。一文件异目录
        - 实现：符号链接、硬链接
        - 注意：遍历、删除
        - 不允许目录硬链接？？？
    - Linux系统目录结构
    - 文件路径名
        - 每进程有当前工作目录
        - 路径名两种形式
            - 绝对路径名：根目录开始
            - 相对路径名：当前目录开始
        - 特殊目录项
            - . 当前
            - .. 上级
- 9.3 文件系统实现
    - 结构
        - IO控制：设备驱动程序、中断处理程序
        - 基本文件系统：读写、IO请求调度、bufferと文件元数据cache
        - 文件组织模块：落块地址转物，磁盘空间分配と管理
        - 逻辑文件系统：管理文系元数据如目录结构、FCB
    - の数据结构
        - 引导控制块/卷：从该卷引导OS所需信息，无OS空
        - 卷控制块：详细信息（分区块数量、快大小、空闲块数量と指针、空闲FCB数量と指针）
        - 目录结构
        - 每文件FCB
    - 内存中な文件系统结构
        - 内存中的安装表（mount table）：文系安装点、文系类型
        - 整个文系打开文件表
        - 每进程打开文件表
        - 目录结构cache（最近访问目录）
        - 磁盘读写buffer
    - 目录の实现
        - 线性列表：要线搜。优化以目录项排序或B+树
        - 哈希表
- 9.4 磁盘空间分配
    - 连续分配
        - 每文件连续磁盘块
        - 优点：简单，支持顺序和随机存取，顺序存取速度快（寻道次数时间）
        - 缺点：不易动态增长、插入删除，碎片
    - 链接分配：指针链之，目录放首末块指针
        - 优点：提高利用率，利于插删，利于扩充
        - 缺点：存取慢不适合随机，链接占空，可靠性
        - 按簇分配：减少指针空间
    - 链接分配变形——文件分配表（FAT）
        - 概述
            - 相当于所有链表指针一起。每个分区、卷开始部分用来。每个磁盘块在FAT中一项。可通过块号索引。目录项有文件首块号，据FAT有下一块，最后一块特殊值，0代表空闲
    - 索引分配：每个文件专用索引快，是磁盘块地址の数组，目录项放索引块地址
        - 优点：可顺序和随机，可动态增删=插，充分利用外存
        - 缺点：索引块指针开销大
        - 文件大而一个磁盘块放不下所有地址，可以多层索引
    - Unix/Linux分配方案：组合索引方案，前15个在文件inode，前12直接指数据块，后3个一级二级三级间接块指针
    - 空闲空间管理
        - 位向量/位图（bit map）：一个位表态，易找连续块，额外空间且常驻内存
        - 链表：低效，大量IO
        - 成组：第一个空闲存n个，最后一个是指向另n个空闲块，大量空闲可找也
- 9.5 文件系统实例
    - 硬盘分区模式
        - MBR：主引导记录（master boot record）
        - GPT：GUID（globally unique identifier） partition table
    - MBR：0柱0磁头1扇区为MBR，第一个扇区也（LBA 0）。不属于任何OS。扩展分区每个逻辑驱动器有类似于MBR的扩展引导记录（extended boot record, EBR）
        - 硬盘引导过程：先BIOS，再MBR
    - GPT：
        - 分区表位置信息存储在GPT头，第一个扇区仍MBR
        - 分区表头LBA1定义可用空间及组成分区表项的大小和数量
    - FAT
        - 概述
            - 磁盘划块，每块扇区大小整数倍，称块为簇。能分为多少簇就FAT多少表项
            - FAT16用16bit表项地址，FAT32为28位，高4为0
            - 一簇最大64扇区
        - FAT32
            - DBR(dos boot record)区是一个OS引导扇区，每个主分区一个DBR，每个逻辑分区也有各自引导扇区
        - 文件分配表FAT
            - 文系にの重要作用：描述簇的分配状态，表明文件或目录下一簇簇号
            - 紧跟在文件保留区后
            - 创建目录给一个簇
        - FAT32目录项
        - 长文件名目录项
    - NTFS
        - 特点：安全性高、可恢复性、文件压缩、磁盘配额
        - 以簇为单位
            - 逻辑簇号（LCN）：分区内所有簇编号
            - 虚拟簇号（VCN）：文件占用的簇从头到尾编号，不要求物理连续
        - 原则：磁盘上任何事物为文件
        - 卷中所有文件在MFT（master file table）的文件记录数组，称为主文件表
        - の元文件
            - $Boot元文件：分区第一个扇区（DBR）、后面15个扇区（NTLDR区域）
        - 文件记录：文件记录头と属性列表
            - 将文件作为属性の集合，这一点不同于其他文系
            - 数据即未命名属性
            - 每个属性は属性头（前四个字节は类型）と属性体
        - 文件属性
            - 常驻、非常驻之分
            - 常驻は文件小，所有属性体都在文件记录
            - 非常驻は文件大，ikb文件记录无法记录所有，在$MFT元文件外存放其他文件记录属性，谓。
    - Ext3文件系统
        - 各种接口的磁盘在Linux中的文件名：？？？
        - Ext3存储布局
            - 存储最小单位は块，相当于簇，大小格式化时确定
            - 整个区域若干有固定数量块的block group
        - 数据块寻址：一个inode128字节，60は指向存放文件内容な数据块指针，每指针4，共15，最后3指针分级间接寻址
            - 单个文件block数最多为……